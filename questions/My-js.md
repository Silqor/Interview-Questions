<h3>
  <img src="../assets/JavaScript.png" width="16" height="16" />
  <span>JavaScript:</span>
</h3>

- Вопрос [Типы данных в JavaScript?]()

  - Ответ [JavaScript поддерживает различные типы данных, которые можно разделить на примитивные и объектные типы. Вот некоторые из них:

  ### Примитивные типы данных:

  1. **Number (Число):**

     - Целые числа или числа с плавающей точкой.

       ```javascript
       let integerNumber = 42;
       let floatNumber = 3.14;
       ```

  2. **String (Строка):**

     - Строки текста.

       ```javascript
       let greeting = 'Привет, мир!';
       ```

  3. **Boolean (Логическое значение):**

     - Истинное или ложное значение.

       ```javascript
       let isTrue = true;
       let isFalse = false;
       ```

  4. **Undefined:**

     - Значение переменной, которая не была инициализирована.

       ```javascript
       let undefinedVariable;
       ```

  5. **Null:**

     - Отсутствие значения.

       ```javascript
       let nullValue = null;
       ```

  6. **Symbol:**

     - Уникальные и неизменяемые значения.

       ```javascript
       let symbol1 = Symbol('a');
       let symbol2 = Symbol('a');
       console.log(symbol1 === symbol2); // false
       ```

  7. **BigInt:**
     `BigInt` относится к примитивным типам данных в JavaScript. `BigInt` является одним из примитивных типов, как и `Number`. Однако, есть некоторые отличия в их использовании и представлении чисел.

     Вот пример:

     ```javascript
     let regularNumber = 42; // тип данных Number
     let bigIntNumber = 42n; // тип данных BigInt
     ```

  Обратите внимание на суффикс `n` в конце числа, который указывает, что это `BigInt`. В отличие от `Number`, который имеет ограниченный диапазон значений, `BigInt` может представлять целые числа произвольной точности.

  ### Объектные типы данных:

  1. **Object (Объект):**

     - Сложные структуры данных.

       ```javascript
       let person = {
         name: 'John',
         age: 30,
         isStudent: false,
       };
       ```

  2. **Array (Массив):**

     - Упорядоченные списки значений.

       ```javascript
       let numbers = [1, 2, 3, 4, 5];
       ```

  3. **Function (Функция):**

     - Блок кода, который может быть вызван.

       ```javascript
       function add(a, b) {
         return a + b;
       }
       ```

  4. **Date (Дата):**

     - Представление даты и времени.

       ```javascript
       let currentDate = new Date();
       ```

  5. **RegExp (Регулярное выражение):**

     - Шаблоны для поиска и манипуляции строк.

       ```javascript
       let pattern = /ab+c/;
       ```

  Это основные типы данных в JavaScript. Каждый из них имеет свои особенности и используется для решения разных задач.]()

- Вопрос [Как скопировать содержимое объекта в другой объект?]()

  - Ответ [
    Для копирования содержимого объекта можно использовать различные методы, например, spread-оператор (...), Object.assign() или JSON.parse() и JSON.stringify().
    Например: javascript

    **Копирование с помощью spread-оператора**
    const originalObj = { name: "John", age: 30 };
    const copyObj = { ...originalObj }
    //оператор расширения (...) также работает для вложенных объектов в JavaScript. Он копирует свойства объекта, включая вложенные объекты, но при этом создает поверхностную копию, то есть вложенные объекты остаются ссылками на те же самые объекты в памяти. Если вы измените вложенный объект в копии, это повлияет и на оригинал, так как это всё ещё будет один и тот же объект.

    **Копирование с помощью Object.assign()**
    const originalObj = { name: "John", age: 30 };
    const copyObj = Object.assign({}, originalObj);
    //Важно отметить, что Object.assign() создает поверхностную копию объекта. Если у объекта есть вложенные объекты, они будут скопированы по ссылке.

    **Глубокое копирование с помощью JSON**
    const originalObj = { name: "John", age: 30 };
    const copyObj = JSON.parse(JSON.stringify(originalObj)); минусы функц  loadash ]()
    //Этот метод создает глубокую копию объекта, но он не будет работать, если объект содержит некоторые типы данных, которые не могут быть сериализованы в JSON (например, функции).

    **Cуществует несколько способов выполнить глубокое копирование объектов в JavaScript. Глубокое копирование означает, что создается копия объекта, а также всех вложенных объектов, рекурсивно. Вот несколько способов для этого:**

    1. **Рекурсивное копирование**: Вы можете создать собственную функцию для рекурсивного копирования объектов и их свойств.

    ```javascript
    function deepCopy(obj) {
      if (obj === null || typeof obj !== 'object') {
        return obj;
      }

      if (Array.isArray(obj)) {
        const newArray = [];
        for (let i = 0; i < obj.length; i++) {
          newArray[i] = deepCopy(obj[i]);
        }
        return newArray;
      }

      const newObj = {};
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          newObj[key] = deepCopy(obj[key]);
        }
      }
      return newObj;
    }

    const original = { a: 1, b: { c: 2 } };
    const copy = deepCopy(original);
    ```

    2. **Использование JSON**: Вы можете преобразовать объект в его JSON-представление и затем обратно. Этот метод работает для объектов, которые могут быть преобразованы в JSON (то есть, без функций и специфических типов данных).

    ```javascript
    const original = { a: 1, b: { c: 2 } };
    const copy = JSON.parse(JSON.stringify(original));
    ```

    3. **Использование библиотек**: Существуют сторонние библиотеки, такие как Lodash, которые предоставляют удобные функции для глубокого копирования объектов, такие как `_.cloneDeep()`.

    ```javascript
    const _ = require('lodash');
    const original = { a: 1, b: { c: 2 } };
    const copy = _.cloneDeep(original);
    ```

    Каждый из этих способов имеет свои особенности и ограничения, поэтому выбор зависит от вашего конкретного случая использования. Глубокое копирование может быть необходимо, если вам нужно создать независимую копию объекта со всеми его вложенными данными.

- Вопрос [Как проверить, является ли объект массивом]()

      - Ответ[В JavaScript есть несколько способов проверить, является ли объект массивом. Вот несколько из них:

  1. **Использование `Array.isArray()`:**

     - Это встроенный метод, добавленный в ECMAScript 5, который возвращает `true`, если переданный аргумент является массивом, и `false` в противном случае.

     ```javascript
     const myArray = [1, 2, 3];

     if (Array.isArray(myArray)) {
       console.log('Это массив!');
     } else {
       console.log('Это не массив!');
     }
     ```

  2. **Проверка свойства `instanceof`:**

     - Мы можем использовать оператор `instanceof`, который возвращает `true`, если объект является экземпляром указанного класса (в данном случае, класса `Array`).

     ```javascript
     const myArray = [1, 2, 3];

     if (myArray instanceof Array) {
       console.log('Это массив!');
     } else {
       console.log('Это не массив!');
     }
     ```

  3. **Проверка наличия свойства `length` и метода `splice()`:**

     - Также можно проверить наличие свойства `length` и метода `splice()`, так как большинство массивов в JavaScript обладают этими свойствами и методами.

     ```javascript
     const myArray = [1, 2, 3];

     if (myArray.length !== undefined && myArray.splice instanceof Function) {
       console.log('Это массив!');
     } else {
       console.log('Это не массив!');
     }
     ```

  Каждый из этих методов может быть использован в зависимости от контекста и требований вашего кода. `Array.isArray()` обычно предпочтителен, так как он является стандартным методом и предоставляет более точную проверку.]()

- Вопрос [Разница между function declaration и function expression?]()

  - Ответ[Различие между объявлением функции (function declaration) и выражением функции (function expression) заключается в том, как функция создается и в том, когда она может быть вызвана в коде.

  ### Function Declaration (Объявление функции):

  ```javascript
  function myFunction() {
    // код функции
  }
  ```

  - **Хостинг (Hoisting):** Объявления функций поднимаются вверх в контексте выполнения кода, что означает, что функцию можно вызывать даже до того, как она фактически объявлена в коде.

  - **Доступность:** Функцию можно вызвать в любом месте кода, даже перед её объявлением.

  ### Function Expression (Выражение функции):

  ```javascript
  var myFunction = function () {
    // код функции
  };
  ```

  - **Хостинг (Hoisting):** В отличие от объявления функции, выражение функции не поднимается вверх, поэтому функцию можно вызвать только после её объявления в коде.

  - **Доступность:** Функцию можно вызывать только после того, как она была присвоена переменной.

  ### Примеры:

  **Function Declaration:**

  ```javascript
  sayHello(); // Работает из-за хостинга

  function sayHello() {
    console.log('Привет!');
  }
  ```

  **Function Expression:**

  ```javascript
  sayHello(); // Ошибка: sayHello is not a function

  var sayHello = function () {
    console.log('Привет!');
  };
  ```

  Важно отметить, что оба способа позволяют создавать функции, и выбор между ними зависит от требований вашего кода. В большинстве случаев использование объявления функции предпочтительно, так как оно обеспечивает более читаемый и предсказуемый код из-за хостинга функций. В то время как выражения функций могут быть полезны, например, при создании анонимных функций или при передаче функции как аргумента в другую функцию.]()

- Вопрос [Что такое область видимости (Scope)?]()

  - Ответ[Область видимости (Scope) в программировании определяет контекст, в пределах которого переменные и функции могут быть использованы или изменены. Область видимости определяет, где в коде можно обращаться к определенным переменным и функциям, а где нельзя. Она ограничивает доступ к переменным и функциям, чтобы предотвратить конфликты и обеспечить порядок и структуру в программе.

  В JavaScript есть два основных типа области видимости:

  1. **Глобальная область видимости (Global Scope):**

     - Переменные и функции, объявленные в глобальной области видимости, доступны из любой части программы, включая функции и блоки кода. Они обладают глобальной видимостью.

       ```javascript
       var globalVariable = 'Глобальная переменная';

       function globalFunction() {
         console.log(globalVariable);
       }

       globalFunction(); // Выведет: "Глобальная переменная"
       ```

     - Переменные, объявленные без использования ключевого слова `var`, `let` или `const`, автоматически становятся свойствами глобального объекта (обычно `window` в браузере).

  2. **Локальная область видимости (Local Scope):**

     - Переменные и функции, объявленные внутри функций или блоков кода, имеют локальную область видимости. Они доступны только в пределах этой функции или блока кода.

       ```javascript
       function localScopeExample() {
         var localVariable = 'Локальная переменная';
         console.log(localVariable);
       }

       localScopeExample(); // Выведет: "Локальная переменная"

       console.log(localVariable); // Ошибка: localVariable не определена
       ```

     - Переменные, объявленные с использованием `let` или `const` в блоке кода, также имеют лексическую область видимости (lexical scope) и доступны только в этом блоке.

  Области видимости обеспечивают изоляцию переменных и функций, что помогает предотвратить конфликты и ошибки в коде. Понимание областей видимости важно для эффективного и безошибочного написания программ на JavaScript и других языках программирования.]()

- Вопрос [Разница между `var`, `let` и `const`?]()

      - Ответ[`var`, `let`, и `const` - это ключевые слова для объявления переменных в JavaScript, но у них есть некоторые различия в отношении области видимости, поведения при поднятии (hoisting), и возможности изменения значения.

  1. **`var`:**

     - Имеет функциональную область видимости (functional scope). Это означает, что переменная, объявленная с использованием `var`, видна внутри всей функции, в которой она была объявлена, независимо от блоков кода.
     - Поднимается (hoisted) в начало функции или глобальной области видимости, что может привести к неожиданному поведению.

       ```javascript
       function example() {
         if (true) {
           var x = 10;
         }
         console.log(x); // Выведет: 10 (не блочная видимость)
       }
       ```

  2. **`let`:**

     - Имеет блочную область видимости (block scope). Это означает, что переменная видна только в том блоке кода, в котором она была объявлена.
     - Поднимается (hoisted) в начало блока, но не видна до своего фактического объявления.

       ```javascript
       function example() {
         if (true) {
           let x = 10;
         }
         console.log(x); // Ошибка: x не определена (блочная видимость)
       }
       ```

  3. **`const`:**

     - Также имеет блочную область видимости и ведет себя, как `let` в этом отношении.
     - Отличие заключается в том, что значение, присвоенное переменной с использованием `const`, не может быть изменено после его присвоения. Она остается постоянной.

       ```javascript
       const PI = 3.14159;
       PI = 3.14; // Ошибка: нельзя изменить значение переменной, объявленной с const
       ```

     - Важно отметить, что `const` не делает объект или массив, на который он ссылается, неизменным. Он защищает только саму переменную от изменений.

  Выбор между `var`, `let`, и `const` зависит от требований вашего кода. Обычно рекомендуется использовать `let` и `const` для улучшения читаемости и предотвращения ошибок, связанных с неожиданным поведением `var`.]()

- Вопрос [Что такое замыкание (Closure)?]()

  - Ответ[Замыкание (Closure) - это особенность в JavaScript, когда функция "запоминает" своё лексическое окружение, даже если эта функция выполняется вне своего исходного контекста. Другими словами, замыкание возникает, когда внутренняя функция запоминает переменные из внешней функции, даже после того, как внешняя функция завершила свою работу.

  Простыми словами, замыкание позволяет функции использовать переменные из её окружения, даже после того, как это окружение перестало существовать.

  Пример:

  ```javascript
  function outerFunction() {
    let outerVariable = 'Я внешняя переменная';

    function innerFunction() {
      console.log(outerVariable);
    }

    return innerFunction;
  }

  const closureExample = outerFunction();
  closureExample(); // Выведет: "Я внешняя переменная"
  ```

  В этом примере функция `innerFunction` сохраняет доступ к переменной `outerVariable`, хотя `outerFunction` уже завершила свою работу. Возвращаемая из `outerFunction` функция `closureExample` формирует замыкание, которое "запоминает" значение `outerVariable`.

  Замыкания могут быть полезными в различных сценариях, таких как создание частных переменных, реализация функций обратного вызова, и в общем, в любых случаях, где необходимо сохранить состояние между вызовами функции.]()

- Вопрос [Что такое `Event loop`]()

      - Ответ[Event Loop (цикл событий) - это механизм в JavaScript, который управляет асинхронным выполнением кода. Он позволяет обрабатывать события, такие как пользовательские вводы, HTTP-запросы, таймеры и другие асинхронные операции, без блокировки основного потока выполнения кода.

  Давайте разберем основные компоненты и принципы работы цикла событий:

  1. **Call Stack (Стек вызовов):**

     - Это структура данных, которая отслеживает, в какой функции находится выполнение кода в данный момент. Когда функция вызывается, она помещается в верхнюю часть стека, а когда функция завершается, она удаляется из стека.

  2. **Message Queue (Очередь сообщений):**

     - Здесь хранятся сообщения и события, которые ожидают своей обработки. Когда асинхронная операция завершается, она добавляет соответствующее сообщение в очередь.

  3. **Event Loop (Цикл событий):**

     - Этот компонент отслеживает стек вызовов и очередь сообщений. Если стек вызовов пуст, а в очереди есть сообщения, цикл событий берет первое сообщение из очереди и помещает его в стек вызовов для выполнения.

  Примерно процесс работы цикла событий может быть представлен следующим образом:

  - Когда код начинает выполнение, он добавляет соответствующие операции в стек вызовов.
  - Если есть асинхронные операции, они запускаются и добавляют соответствующие сообщения в очередь.
  - Когда стек вызовов освобождается (стек пуст), цикл событий берет первое сообщение из очереди и помещает его в стек вызовов.
  - Операции внутри сообщения выполняются, и процесс повторяется.

  Пример с использованием `setTimeout`:

  ```javascript
  console.log('Начало');

  setTimeout(function () {
    console.log('Таймер сработал');
  }, 2000);

  console.log('Конец');
  ```

  В этом примере первоначальный код выполняется, затем `setTimeout` добавляет сообщение в очередь через 2 секунды. В течение этих двух секунд цикл событий может обрабатывать другие задачи, и только после этого выполнится функция, переданная в `setTimeout`.

  Цикл событий в JavaScript обеспечивает асинхронность и позволяет эффективно управлять различными асинхронными задачами в веб-приложениях.]()

- Вопрос [Что обозначает `this` в JavaScript?]()

  - Ответ[В JavaScript ключевое слово `this` используется для ссылки на текущий объект, в контексте которого выполняется код. Значение `this` зависит от того, как вызывается функция или метод. Здесь несколько основных сценариев, в которых может использоваться `this`:

  1. **Глобальный контекст:**

     - Вне функций `this` ссылается на глобальный объект, который в браузере обычно является объектом `window`.

     ```javascript
     console.log(this); // Выведет глобальный объект (например, window в браузере)
     ```

  2. **Внутри функции:**

     - Внутри обычной функции `this` также ссылается на глобальный объект, если функция вызвана в глобальном контексте. Однако, если функция вызывается в контексте объекта, то `this` ссылается на этот объект.

     ```javascript
     function myFunction() {
       console.log(this);
     }

     myFunction(); // Выведет глобальный объект

     var obj = {
       myMethod: myFunction,
     };

     obj.myMethod(); // Выведет объект obj
     ```

  3. **Внутри метода объекта:**

     - Внутри метода объекта `this` ссылается на сам объект, в контексте которого вызван метод.

     ```javascript
     var obj = {
       prop: 'Значение',
       myMethod: function () {
         console.log(this.prop);
       },
     };

     obj.myMethod(); // Выведет "Значение"
     ```

  4. **В конструкторе:**

     - Внутри конструктора `this` ссылается на экземпляр объекта, который будет создан при вызове конструктора с использованием оператора `new`.

     ```javascript
     function MyClass(value) {
       this.prop = value;
     }

     var myObject = new MyClass('Значение');
     console.log(myObject.prop); // Выведет "Значение"
     ```

  5. **В обработчиках событий:**

     - Внутри обработчиков событий `this` обычно ссылается на элемент, к которому привязан обработчик.

     ```javascript
     var button = document.getElementById('myButton');
     button.addEventListener('click', function () {
       console.log(this); // Выведет элемент button
     });
     ```

  Это лишь несколько примеров. Значение `this` может меняться в зависимости от контекста вызова функции, и понимание того, как оно работает, важно для правильной работы с объектами и функциями в JavaScript.]()

- Вопрос [Что такое `NaN`? Как определить, что значение равно `NaN`?]()

  - Ответ[`NaN` - это специальное значение в JavaScript, которое обозначает "не число" (Not-a-Number). Оно возвращается в тех случаях, когда математическая операция не может быть выполнена или не имеет смысла. Например, деление нуля на ноль, попытка преобразования неподходящей строки в число и некоторые другие сценарии могут привести к получению значения `NaN`.

  Примеры, приводящие к `NaN`:

  ```javascript
  console.log(0 / 0); // NaN
  console.log('строка' / 2); // NaN
  console.log(Math.sqrt(-1)); // NaN
  ```

  Чтобы определить, что значение равно `NaN`, вы можете использовать функцию `isNaN()`:

  ```javascript
  console.log(isNaN(NaN)); // true
  console.log(isNaN(123)); // false
  console.log(isNaN('строка')); // true
  console.log(isNaN('123')); // false
  console.log(isNaN('Не число')); // true
  ```

  Однако, стоит отметить, что `isNaN()` имеет несколько особенностей. Он пытается преобразовать переданное значение в число перед проверкой. Это может привести к неожиданным результатам. Например:

  ```javascript
  console.log(isNaN('123abc')); // true, так как "123abc" не может быть преобразовано в число
  console.log(isNaN('')); // false, так как пустая строка может быть преобразована в 0
  ```

  Для более точной проверки на `NaN` и исключения этих особенностей, вы можете использовать функцию `Number.isNaN()`:

  ```javascript
  console.log(Number.isNaN(NaN)); // true
  console.log(Number.isNaN(123)); // false
  console.log(Number.isNaN('строка')); // false
  console.log(Number.isNaN('123')); // false
  console.log(Number.isNaN('123abc')); // false
  console.log(Number.isNaN('')); // false
  ```

  `Number.isNaN()` возвращает `true` только в том случае, если переданное значение строго равно `NaN`, и не преобразует его в число перед проверкой.

  **Является ли он типом данных в js?**
  `NaN` (Not-a-Number) не является отдельным типом данных в JavaScript. Вместо этого, `NaN` представляет собой специальное значение, которое относится к типу данных Number. Таким образом, `NaN` является значением, которое может быть присвоено переменным, имеющим тип данных Number.

  Вот пример:

  ```javascript
  let myVariable = NaN;
  console.log(typeof myVariable); // Выведет "number"
  ```

  Таким образом, `NaN` - это значение, которое указывает на неопределенное или некорректное числовое значение в контексте языка JavaScript. Оно используется для обозначения результатов математических операций, которые не могут быть корректно выполнены.
  ]()

- Вопрос [Методы массивов в JavaScript?]()

      - Ответ[JavaScript предоставляет множество методов для работы с массивами. Вот несколько основных методов массивов:

  1. **`push()`**

     - Добавляет один или несколько элементов в конец массива и возвращает новую длину массива.

     ```javascript
     const fruits = ['яблоко', 'груша'];
     const newLength = fruits.push('апельсин', 'банан');
     console.log(fruits); // ["яблоко", "груша", "апельсин", "банан"]
     console.log(newLength); // 4
     ```

  2. **`pop()`**

     - Удаляет последний элемент из массива и возвращает его.

     ```javascript
     const fruits = ['яблоко', 'груша', 'апельсин', 'банан'];
     const lastFruit = fruits.pop();
     console.log(fruits); // ["яблоко", "груша", "апельсин"]
     console.log(lastFruit); // "банан"
     ```

  3. **`shift()`**

     - Удаляет первый элемент из массива и возвращает его.

     ```javascript
     const fruits = ['яблоко', 'груша', 'апельсин', 'банан'];
     const firstFruit = fruits.shift();
     console.log(fruits); // ["груша", "апельсин", "банан"]
     console.log(firstFruit); // "яблоко"
     ```

  4. **`unshift()`**

     - Добавляет один или несколько элементов в начало массива и возвращает новую длину массива.

     ```javascript
     const fruits = ['груша', 'апельсин', 'банан'];
     const newLength = fruits.unshift('яблоко', 'киви');
     console.log(fruits); // ["яблоко", "киви", "груша", "апельсин", "банан"]
     console.log(newLength); // 5
     ```

  5. **`splice()`**

     - Изменяет содержимое массива, удаляя или заменяя существующие элементы и/или добавляя новые элементы в нужные позиции.

     ```javascript
     const fruits = ['яблоко', 'груша', 'апельсин', 'банан'];
     fruits.splice(1, 2, 'киви', 'вишня');
     console.log(fruits); // ["яблоко", "киви", "вишня", "банан"]
     ```

  6. **`slice()`**

     - Возвращает выбранный участок массива в виде нового массива, не изменяя оригинальный массив.

     ```javascript
     const fruits = ['яблоко', 'груша', 'апельсин', 'банан'];
     const citrus = fruits.slice(2);
     console.log(citrus); // ["апельсин", "банан"]
     console.log(fruits); // ["яблоко", "груша", "апельсин", "банан"]
     ```

  Это лишь несколько основных методов массивов в JavaScript. В языке также есть множество других полезных методов, таких как `map()`, `filter()`, `forEach()`, `reduce()` и многие другие.

  **Раасскажи про map(), filter(), forEach(), reduce()**
  Каждый из методов `map()`, `filter()`, `forEach()` и `reduce()` предоставляет функциональные возможности для работы с массивами в JavaScript.

  1. **`map()`**

     - Метод `map()` создает новый массив, применяя функцию к каждому элементу исходного массива. Он возвращает новый массив, содержащий результаты выполнения функции.

     ```javascript
     const numbers = [1, 2, 3, 4, 5];
     const squaredNumbers = numbers.map(function (number) {
       return number * number;
     });
     console.log(squaredNumbers); // [1, 4, 9, 16, 25]
     ```

  2. **`filter()`**

     - Метод `filter()` создает новый массив, включая только те элементы исходного массива, для которых функция возвращает `true`.

     ```javascript
     const numbers = [1, 2, 3, 4, 5];
     const evenNumbers = numbers.filter(function (number) {
       return number % 2 === 0;
     });
     console.log(evenNumbers); // [2, 4]
     ```

  3. **`forEach()`**

     - Метод `forEach()` выполняет функцию для каждого элемента массива, но не создает новый массив. Этот метод полезен, когда вы хотите выполнить какое-то действие для каждого элемента, но не нуждаетесь в возвращаемом массиве.

     ```javascript
     const colors = ['red', 'blue', 'green'];
     colors.forEach(function (color) {
       console.log(color);
     });
     // Выведет:
     // red
     // blue
     // green
     ```

  4. **`reduce()`**

     - Метод `reduce()` используется для свертывания массива в единственное значение. Он принимает функцию, которая аккумулирует результат, и начальное значение аккумулятора.

     ```javascript
     const numbers = [1, 2, 3, 4, 5];
     const sum = numbers.reduce(function (accumulator, currentValue) {
       return accumulator + currentValue;
     }, 0);
     console.log(sum); // 15
     ```

     - В данном примере, `0` - это начальное значение аккумулятора. Функция, переданная в `reduce()`, выполняется для каждого элемента массива, принимая текущее значение аккумулятора и текущий элемент. В результате, `reduce()` возвращает окончательное значение аккумулятора.

  Эти методы предоставляют удобные инструменты для работы с массивами в JavaScript и позволяют выполнять различные операции, такие как преобразование данных, фильтрация, итерация и свертка.
  ]()

- Вопрос [Методы строк в JavaScript?]()

  - Ответ[JavaScript предоставляет множество методов для работы со строками. Вот несколько основных методов строк:

  1. **`length`**

  - Свойство `length` возвращает количество символов в строке.

  ```javascript
  const myString = 'Привет, мир!';
  console.log(myString.length); // 12
  ```

  2. **`charAt(index)`**

  - Метод `charAt()` возвращает символ в указанной позиции строки.

  ```javascript
  const myString = 'JavaScript';
  console.log(myString.charAt(2)); // "v"
  ```

  3. **`concat(...strings)`**

  - Метод `concat()` объединяет строки, создавая новую строку.

  ```javascript
  const str1 = 'Hello';
  const str2 = ' ';
  const str3 = 'World';
  const greeting = str1.concat(str2, str3);
  console.log(greeting); // "Hello World"
  ```

  4. **`indexOf(substring, startIndex)`**

  - Метод `indexOf()` возвращает индекс первого вхождения подстроки в строке, начиная с указанной позиции (или с начала, если позиция не указана).

  ```javascript
  const myString = 'Hello, world!';
  console.log(myString.indexOf('world')); // 7
  ```

  5. **`slice(startIndex, endIndex)`**

  - Метод `slice()` возвращает подстроку, начиная с указанной позиции и заканчивая указанной позицией (не включая её).

  ```javascript
  const myString = 'JavaScript';
  console.log(myString.slice(0, 4)); // "Java"
  ```

  6. **`toUpperCase()` и `toLowerCase()`**

  - Методы `toUpperCase()` и `toLowerCase()` возвращают новую строку, в которой все символы преобразованы в верхний или нижний регистр соответственно.

  ```javascript
  const myString = 'JavaScript';
  console.log(myString.toUpperCase()); // "JAVASCRIPT"
  console.log(myString.toLowerCase()); // "javascript"
  ```

  7. **`replace(searchValue, replaceValue)`**

  - Метод `replace()` заменяет первое вхождение указанной подстроки на другую подстроку.

  ```javascript
  const myString = 'Hello, world!';
  const newString = myString.replace('world', 'JavaScript');
  console.log(newString); // "Hello, JavaScript!"
  ```

  8. **`split(separator)`**

  - Метод `split()` разбивает строку на массив подстрок, используя указанный разделитель.

  ```javascript
  const myString = 'apple,orange,banana';
  const fruitsArray = myString.split(',');
  console.log(fruitsArray); // ["apple", "orange", "banana"]
  ```

  Это всего лишь несколько примеров методов строк в JavaScript. Существует множество других методов, предоставляющих различные функциональности для работы с текстом.]()

- Вопрос [Что такое функции высшего порядка (Higher Order Functions)?]()

      - Ответ[Функции высшего порядка (Higher Order Functions) в программировании — это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата. Функции высшего порядка являются основой функционального программирования и позволяют писать более абстрактный, гибкий и переиспользуемый код.

  Вот несколько примеров функций высшего порядка:

  1. **Принимание функции в качестве аргумента:**

     ```javascript
     // Пример: функция, принимающая функцию в качестве аргумента
     function doOperation(operation, a, b) {
       return operation(a, b);
     }

     // Функция, передаваемая в качестве аргумента
     function add(a, b) {
       return a + b;
     }

     // Использование функции высшего порядка
     const result = doOperation(add, 5, 3);
     console.log(result); // 8
     ```

  2. **Возвращение функции в качестве результата:**

     ```javascript
     // Пример: функция, возвращающая функцию
     function multiplier(factor) {
       return function (x) {
         return x * factor;
       };
     }

     // Использование функции высшего порядка
     const double = multiplier(2);
     console.log(double(5)); // 10
     ```

  3. **Методы массивов:**
     Многие методы массивов в JavaScript являются функциями высшего порядка. Например, `map()`, `filter()`, `reduce()` принимают функцию в качестве аргумента и выполняют её для каждого элемента массива.

     ```javascript
     const numbers = [1, 2, 3, 4, 5];

     // map: преобразование каждого элемента массива
     const squaredNumbers = numbers.map(function (number) {
       return number * number;
     });
     console.log(squaredNumbers); // [1, 4, 9, 16, 25]

     // filter: фильтрация элементов массива
     const evenNumbers = numbers.filter(function (number) {
       return number % 2 === 0;
     });
     console.log(evenNumbers); // [2, 4]

     // reduce: свертка массива в единственное значение
     const sum = numbers.reduce(function (accumulator, currentValue) {
       return accumulator + currentValue;
     }, 0);
     console.log(sum); // 15
     ```

  Функции высшего порядка упрощают код, делают его более гибким и часто способствуют созданию более читаемого и понятного программного кода.]()

- Вопрос []()

  - Ответ[]()

- Вопрос []()

  - Ответ[]()

- Вопрос []()

  - Ответ[]()

- Вопрос []()

  - Ответ[]()

- Вопрос []()

  - Ответ[]()

- Вопрос []()

  - Ответ[]()

- Вопрос []()

  - Ответ[]()

- [Разница между `==` и `===` (нестрогое/строгое равенство)?](https://youtu.be/ycYp7CYOnO0?t=529)
- [Что такое Strict mode в JavaScript?](https://youtu.be/ycYp7CYOnO0?t=577)
- [Разница между `null` и `undefined`?](https://youtu.be/G7hLwudGWL4?t=511)
- [Типы таймеров в JavaScript?](https://youtu.be/G7hLwudGWL4?t=690)
- [Что такое поднятие (Hoisting)?](https://youtu.be/G7hLwudGWL4?t=552)
- [Что обозначает `this` в JavaScript?](https://youtu.be/rlWgI7AvV18?t=507)

- [Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?](https://youtu.be/CjdCxxqObaM?t=368)
- [Что такое чистая функция?](https://youtu.be/rlWgI7AvV18?t=401)
- [Разница между `.forEach()` и `.map()`?](https://youtu.be/rlWgI7AvV18?t=456)
- [Разница между `.call()`, `.apply()` и `bind()`?](https://youtu.be/rlWgI7AvV18?t=548)
- [Почему в JS функции называют объектами первого класса?](https://youtu.be/rlWgI7AvV18?t=624)
- [Как определить наличие свойства в объекте?](https://youtu.be/kx3dR6ztICU?t=226)
- [Что такое IIFE?](https://youtu.be/kx3dR6ztICU?t=396)
- [Что такое псевдомассив `arguments`?](https://youtu.be/kx3dR6ztICU?t=442)
- [Разница между host-объектами и нативными объектами?](https://youtu.be/kx3dR6ztICU?t=484)
- [Почему результат сравнения 2х объектов это `false`?](https://youtu.be/IooJ3P2VUYs?t=100)
- [Что такое прототипное наследование? Как создать объект без прототипа?](https://youtu.be/IooJ3P2VUYs?t=154)
- [Почему расширение нативных JavaScript-объектов это плохая практика?](https://youtu.be/IooJ3P2VUYs?t=202)
- [Что такое `NaN`? Как определить, что значение равно `NaN`?](https://youtu.be/IooJ3P2VUYs?t=266)
- [Что такое объектная обертка (Wrapper Objects)?](https://youtu.be/w-vUj0gHGgg?t=26)
- [Как в JavaScript создать объект?](https://youtu.be/w-vUj0gHGgg?t=83)
- [Для чего используется ключевое слово `new`?](https://youtu.be/w-vUj0gHGgg?t=125)
- [Операторы «И» и «ИЛИ» (`&&` и `||`)?](https://youtu.be/G7hLwudGWL4?t=617)
- [Для чего используется оператор двойного отрицания (`!!`)?](https://youtu.be/G4iYlbilozM?t=26)
- [Для чего используется оператор остатка (`%`)?](https://youtu.be/G4iYlbilozM?t=88)
- [Как проверить, является ли значение массивом?](https://youtu.be/G4iYlbilozM?t=68)
- [Как работает boxing/unboxing в JavaScript?](https://youtu.be/G4iYlbilozM?t=149)
- [Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?](https://youtu.be/nvktMVFM0_M?t=30)
- [Разница между оператором `in` и методом `.hasOwnProperty()`?](https://youtu.be/nvktMVFM0_M?t=102)
- [Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?](https://youtu.be/nvktMVFM0_M?t=125)
- [Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?](https://youtu.be/nvktMVFM0_M?t=200)
- [Что такое необъявленная переменная?](https://youtu.be/nvktMVFM0_M?t=236)
- [Как передаются параметры в функцию: по ссылке или по значению?](https://youtu.be/nvktMVFM0_M?t=280)
- [Что такое прототип объекта в JavaScript?](https://youtu.be/yvOXvZ8aEFo?t=287)
- [Как работает метод `Object.create()`?](https://youtu.be/V-m0sQ-hW58?t=28)
- [Разниц между `Object.freeze()` и `Object.seal()`?](https://youtu.be/xZLxdts7ZW4?t=374)
- [Разница между методами `.slice()` и `.splice()`?](https://youtu.be/XtQPrt8G0n8?t=679)
- [Как работают методы `.find()`, `.findIndex()` и `.indexOf()`?](https://youtu.be/xZLxdts7ZW4?t=488)
- [Плюсы и минусы использования `use strict`?](https://youtu.be/xZLxdts7ZW4?t=549)
- [Разница между методами `.push()`, `.pop()`, `.shift()` и `.unshift()`?](https://youtu.be/ngyOYuTrUk8?t=385)
- [Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?](https://youtu.be/ngyOYuTrUk8?t=445)
- [Типы всплывающих окон в JavaScript?](https://youtu.be/ngyOYuTrUk8?t=515)
- [Типы объектов JavaScript?](https://youtu.be/ngyOYuTrUk8?t=595)
- [Парадигмы программирования в JavaScript?](https://youtu.be/ngyOYuTrUk8?t=653)
- [Типы ошибок в JavaScript?](https://youtu.be/ovV8GhIkzBE?t=754)
- [Разница между `typeof` и `instanceof`?](https://youtu.be/ovV8GhIkzBE?t=835)
- [JavaScript статически, или динамически типизированный язык?](https://youtu.be/V-m0sQ-hW58?t=98)
- [Что такое регулярное выражение (Regular Expression)?](https://youtu.be/V-m0sQ-hW58?t=146)
- [Что такое рекурсия?](https://youtu.be/V-m0sQ-hW58?t=220)
- [Что такое прототип (Prototype) объекта?](https://youtu.be/V-m0sQ-hW58?t=290)
- [Какие методы используются в регулярных выражениях?](https://youtu.be/XtQPrt8G0n8?t=495)
- [Что такое полифил (polyfill)?](https://youtu.be/XtQPrt8G0n8?t=557)
- [Что такое `switch/case`? Правила использования `switch/case`?](https://youtu.be/XtQPrt8G0n8?t=600)
- [Типы функций по способности принимать другие функции?](https://youtu.be/XtQPrt8G0n8?t=726)
- [Что такое выражения (expression) и инструкции (statement) в JavaScript?](https://youtu.be/VYQl2GhbCUs?t=706)
- [Разница между `.some()` и `.every()`?](https://youtu.be/VYQl2GhbCUs?t=762)
- [Как сгенерировать случайное число в JavaScript?](https://youtu.be/VYQl2GhbCUs?t=801)
- [Типы операторов в JavaScript?](https://youtu.be/lZNWrW39ELM?t=30)
- [Разница между параметром и аргументом функции?](https://youtu.be/lZNWrW39ELM?t=144)
- [Правила задания имён для переменных и функций в JavaScript?](https://youtu.be/lZNWrW39ELM?t=173)
- [Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?](https://youtu.be/lZNWrW39ELM?t=232)
- [Для чего применяется метод `Array.from()`?](https://youtu.be/lZNWrW39ELM?t=328)
- [Назовите способы преобразования массива в объект?](https://youtu.be/lZNWrW39ELM?t=389)
- [Разница между `Object` и `Map`?](https://youtu.be/nbWY5W-9OEo?t=214)
- [Что такое каррирование?](https://youtu.be/nbWY5W-9OEo?t=295)
- [Для чего используются метод `Object.seal()`?](https://youtu.be/nbWY5W-9OEo?t=354)
- [Для чего используется свойство `.dataset`?](https://youtu.be/3NGkctg4lsE?t=680)
- [Каким образом можно обмениваться кодом между файлами?](https://youtu.be/3NGkctg4lsE?t=744)
- [Как работает «сборщик мусора» в JavaScript?](https://youtu.be/trriSYNrHw4?t=786)
- [Что такое утечки памяти?](https://youtu.be/3NGkctg4lsE?t=815)
- [Назовите основные типы утечек памяти в JavaScript?](https://youtu.be/3NGkctg4lsE?t=874)
- [Как работает контекст выполнения (execution context) в JavaScript?](https://youtu.be/nTE4qvSvxXY?t=704)
- [Разница между примитивом и объектом?](https://youtu.be/nTE4qvSvxXY?t=791)
- [Что значит текст `max call stack size exceeded` в консоли?](https://youtu.be/ia3VPHMESnY?t=781)
- [Как реализовать отложенную загрузку изображений?](https://youtu.be/zcF-CVtXSBI?t=540)
- [Чем отличаются события `input` и `change`?](https://youtu.be/zcF-CVtXSBI?t=607)
- [Почему `typeof null` возвращает `object`?](https://youtu.be/zcF-CVtXSBI?t=638)
- [Зачем нужен конструктор `Proxy`?](https://youtu.be/zcF-CVtXSBI?t=690)
