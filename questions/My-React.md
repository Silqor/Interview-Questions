<h3>
  <img src="../assets/React.png" width="16" height="16" />
  <span>React:</span>
</h3>

- Вопрос [Что такое React?]()
  **React** — это популярная JavaScript-библиотека для создания пользовательских интерфейсов (UI). React был разработан и поддерживается Facebook, а также активно используется и развивается сообществом разработчиков. React помогает строить компоненты пользовательского интерфейса с использованием декларативного подхода, что упрощает разработку, тестирование и поддержку сложных веб-приложений.

  ### Основные особенности React:

  1. **Компонентный подход:**

  - В React пользовательский интерфейс строится из компонентов. Компоненты — это независимые, переиспользуемые части интерфейса, которые могут включать в себя разметку, логику и стили. Компоненты могут быть как простыми (например, кнопка), так и сложными (например, форма с несколькими полями ввода).

  2. **Декларативный стиль программирования:**

  - React использует декларативный подход для описания того, как должен выглядеть интерфейс в зависимости от состояния приложения. Вместо того чтобы описывать пошагово, как изменить DOM, вы описываете, как должен выглядеть интерфейс в данный момент, а React автоматически обновляет DOM, чтобы отразить эти изменения.

  3. **JSX:**

  - JSX (JavaScript XML) — это синтаксическое расширение для JavaScript, которое позволяет писать HTML-подобную разметку непосредственно в коде JavaScript. JSX используется в React для описания того, как должен выглядеть компонент. Это упрощает процесс создания интерфейсов и делает код более наглядным.
  - Пример JSX:
    ```jsx
    const element = <h1>Hello, world!</h1>;
    ```

  4. **Виртуальный DOM:**

  - React использует концепцию виртуального DOM (Virtual DOM) для повышения производительности. Виртуальный DOM — это легковесное представление реального DOM. Когда происходит изменение состояния компонента, React сначала обновляет виртуальный DOM, а затем минимально изменяет реальный DOM, что значительно ускоряет обновление интерфейса.

  5. **Однонаправленный поток данных:**

  - В React данные передаются сверху вниз (от родителя к дочерним компонентам) через свойства (props). Это упрощает понимание того, как данные проходят через приложение, и делает логику компонентов более предсказуемой.

  6. **Управление состоянием:**

  - React позволяет управлять состоянием компонентов через объект `state`. Состояние компонента — это данные, которые могут изменяться в течение времени и влиять на отображение компонента. В функциональных компонентах состояние управляется с помощью хука `useState`.

  7. **Совместимость с другими библиотеками и фреймворками:**

  - React фокусируется только на "V" в концепции MVC (Model-View-Controller), что делает его гибким для интеграции с другими библиотеками и фреймворками, такими как Redux для управления состоянием, React Router для маршрутизации, и многими другими.

  8. **Рендеринг на сервере (SSR) и статическая генерация (SSG):**

  - React поддерживает рендеринг на стороне сервера (Server-Side Rendering, SSR) и статическую генерацию (Static Site Generation, SSG), что позволяет улучшить производительность и SEO, используя фреймворки, такие как Next.js.

  ### Пример простого React-компонента:

  ```jsx
  import React from 'react';

  function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
  }

  export default Welcome;
  ```

  Этот компонент принимает свойство `name` и отображает приветствие.

  ### Заключение:

  React — это мощная и гибкая библиотека для создания пользовательских интерфейсов. Благодаря своей компонентной архитектуре, декларативному подходу и поддержке виртуального DOM, React позволяет разработчикам создавать быстрые и масштабируемые веб-приложения. React активно используется как в крупных компаниях, так и в малых проектах, и остаётся одним из самых популярных инструментов в современном веб-разработке.

- Вопрос [Перечислите особенности React?]()
  React обладает рядом особенностей, которые делают его мощным инструментом для разработки пользовательских интерфейсов. Вот ключевые особенности React:

  ### 1. **Компонентный подход:**

  - **Описание:** React основан на компонентной архитектуре, где интерфейс разбивается на отдельные, независимые и переиспользуемые компоненты. Каждый компонент управляет своим состоянием и может быть встроен в другие компоненты для создания сложных интерфейсов.
  - **Преимущества:** Повторное использование кода, упрощение разработки и тестирования, улучшение поддерживаемости кода.

  ### 2. **Декларативный стиль программирования:**

  - **Описание:** React позволяет разработчикам описывать, как должен выглядеть пользовательский интерфейс в любой момент времени. В отличие от императивного программирования, где вы указываете шаги для достижения результата, декларативный подход описывает сам результат, а React занимается обновлением интерфейса.
  - **Преимущества:** Упрощение логики обновления интерфейса, уменьшение числа ошибок и более читаемый код.

  ### 3. **JSX (JavaScript XML):**

  - **Описание:** JSX — это синтаксическое расширение JavaScript, которое позволяет писать HTML-подобную разметку прямо в коде JavaScript. JSX используется в React для описания того, как должен выглядеть компонент.
  - **Преимущества:** Повышенная читабельность кода, возможность использования всей силы JavaScript в разметке, лучшая интеграция с кодом.

  ### 4. **Виртуальный DOM (Virtual DOM):**

  - **Описание:** Виртуальный DOM — это легковесное представление реального DOM, которое React использует для отслеживания изменений. Когда состояние компонента меняется, React сначала обновляет виртуальный DOM, а затем минимально изменяет реальный DOM на основе этих изменений.
  - **Преимущества:** Повышение производительности, так как обновления реального DOM производятся только при необходимости и только те элементы, которые изменились.

  ### 5. **Однонаправленный поток данных:**

  - **Описание:** В React данные передаются сверху вниз, от родительского компонента к дочерним компонентам через свойства (props). Это делает логику работы приложения более предсказуемой и управляемой.
  - **Преимущества:** Упрощение отладки и понимания того, как данные движутся через приложение.

  ### 6. **Управление состоянием:**

  - **Описание:** React предоставляет возможность управлять состоянием компонентов через объект `state`. Состояние — это данные, которые могут изменяться в ходе работы приложения и влиять на то, как отображается компонент. В функциональных компонентах для этого используется хук `useState`.
  - **Преимущества:** Гибкость в управлении состоянием компонентов, возможность обновления интерфейса при изменении состояния.

  ### 7. **Рендеринг на стороне сервера (SSR) и статическая генерация (SSG):**

  - **Описание:** React поддерживает рендеринг на стороне сервера (Server-Side Rendering, SSR) и статическую генерацию (Static Site Generation, SSG) с помощью фреймворков, таких как Next.js. Это позволяет создавать более быстрые и SEO-оптимизированные приложения.
  - **Преимущества:** Улучшение производительности, поддержка SEO, возможность предварительной загрузки данных.

  ### 8. **Поддержка хуков (Hooks):**

  - **Описание:** Хуки — это функции, которые позволяют использовать состояния и другие возможности React в функциональных компонентах. Основные хуки включают `useState`, `useEffect`, `useContext` и другие.
  - **Преимущества:** Возможность использования состояний и побочных эффектов в функциональных компонентах, упрощение логики и структуры компонентов.

  ### 9. **Совместимость с другими библиотеками и фреймворками:**

  - **Описание:** React можно использовать в сочетании с другими библиотеками и фреймворками. Например, для управления состоянием можно использовать Redux, а для маршрутизации — React Router.
  - **Преимущества:** Гибкость интеграции с другими инструментами, возможность расширения функциональности приложения.

  ### 10. **Сообщество и экосистема:**

  - **Описание:** React имеет большое и активное сообщество, что обеспечивает наличие множества готовых библиотек, инструментов и обучающих материалов. Это делает React отличным выбором для разработки как небольших, так и крупных проектов.
  - **Преимущества:** Поддержка сообщества, доступность множества инструментов и плагинов, возможность быстрой разработки.

  ### Заключение:

  React — это мощная библиотека для создания пользовательских интерфейсов, обладающая множеством особенностей, которые делают его гибким и удобным для разработки современных веб-приложений. Компонентный подход, декларативный стиль, виртуальный DOM и хуки — это лишь некоторые из возможностей, которые делают React одним из самых популярных инструментов в веб-разработке.

- Вопрос [Что такое Virtual DOM? Как он работает с React?]()
  **Virtual DOM (Виртуальный DOM)** — это легковесное представление реального DOM, которое используется в React для оптимизации процесса обновления пользовательского интерфейса. Виртуальный DOM позволяет React эффективно управлять изменениями в интерфейсе, минимизируя количество операций с реальным DOM, которые являются одними из самых затратных по времени операций в браузере.

  ### Как работает Virtual DOM в React:

  1. **Создание виртуального DOM:**

  - Когда компонент React рендерится, создается дерево объектов, представляющих виртуальный DOM. Это дерево отражает структуру реального DOM, но оно находится в памяти и не связано напрямую с реальным DOM в браузере.

  2. **Изменение состояния компонента:**

  - Когда состояние (state) или свойства (props) компонента изменяются, React вызывает повторный рендеринг компонента, что приводит к созданию нового виртуального DOM для этого компонента. Это новое дерево виртуального DOM сравнивается со старым деревом.

  3. **Diffing (сравнение):**

  - React использует алгоритм сравнения (diffing), чтобы определить минимальный набор изменений, необходимых для обновления реального DOM. Алгоритм diffing работает по правилам, которые позволяют эффективно находить различия между новым и старым виртуальным DOM.

  4. **Патчинг (обновление реального DOM):**

  - После того как React вычисляет, какие изменения необходимы, он применяет их к реальному DOM. Это делается через минимальное количество операций, что значительно ускоряет процесс обновления интерфейса по сравнению с непосредственной работой с реальным DOM.

  ### Пример работы Virtual DOM:

  1. **Первоначальный рендеринг:**

  - Когда React-компонент рендерится впервые, создается виртуальный DOM и затем отображается на экране с помощью реального DOM.

  2. **Изменение состояния:**

  - Представьте, что пользователь взаимодействует с приложением (например, вводит текст в поле ввода), что приводит к изменению состояния компонента. React создает новый виртуальный DOM, чтобы отразить эти изменения.

  3. **Сравнение виртуальных DOM:**

  - React сравнивает новый виртуальный DOM с предыдущей версией. Например, если пользователь изменил текст в поле ввода, React обнаружит, что изменился только текст внутри этого элемента, а не весь компонент.

  4. **Обновление реального DOM:**

  - React обновит только текстовое содержимое конкретного элемента в реальном DOM, а не весь компонент. Это делает процесс обновления очень быстрым и эффективным.

  ### Преимущества использования Virtual DOM:

  - **Производительность:** Виртуальный DOM минимизирует количество операций с реальным DOM, что ускоряет обновление пользовательского интерфейса, особенно в сложных и больших приложениях.
  - **Упрощение разработки:** Разработчикам не нужно вручную управлять изменениями в DOM. React берет на себя заботу о том, какие изменения нужно внести в DOM, на основе сравнений виртуального DOM.

  - **Повышение отзывчивости приложения:** Благодаря оптимизации изменений в реальном DOM, React может быстрее реагировать на действия пользователя, обеспечивая плавное и отзывчивое взаимодействие.

  ### Заключение:

  Виртуальный DOM — это одна из ключевых концепций, лежащих в основе производительности и эффективности React. Благодаря использованию виртуального DOM, React может значительно снизить количество операций с реальным DOM, обеспечивая быстрое и плавное обновление пользовательских интерфейсов. Это делает React мощным инструментом для создания интерактивных и отзывчивых веб-приложений.

- Вопрос [Для чего нужен атрибут `key` при рендере списков?]()
  Атрибут `key` в React используется для помощи в идентификации элементов списка при их рендере. Этот атрибут является важной частью рендеринга списков в React и необходим для повышения производительности и правильного обновления интерфейса.

  ### Основные задачи атрибута `key`:

  1. **Уникальная идентификация элементов:**

  - React использует `key` для идентификации каждого элемента в списке. Это позволяет React отслеживать, какие элементы изменились, были добавлены или удалены. Когда состояние компонента изменяется, React сравнивает предыдущую и текущую версии списка, чтобы определить, какие элементы необходимо обновить.

  2. **Оптимизация рендеринга:**

  - С помощью `key` React может эффективно обновлять только те элементы, которые изменились, а не перерисовывать весь список. Это значительно повышает производительность, особенно при работе с большими списками, так как React не будет перерендеривать все элементы, а только те, которые действительно изменились.

  3. **Избежание ошибок при рендере:**

  - Если элементы списка не имеют уникальных ключей, React может неправильно отслеживать изменения в списке, что может привести к ошибкам отображения и некорректному поведению компонентов.

  ### Пример использования `key`:

  ```jsx
  function TodoList({ todos }) {
    return (
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    );
  }
  ```

  В этом примере у каждого элемента `<li>` есть уникальный атрибут `key`, основанный на `todo.id`. Это гарантирует, что React сможет правильно отслеживать каждый элемент в списке, даже если элементы будут добавляться, удаляться или изменяться.

  ### Как выбирать значения для `key`:

  - **Уникальность:** Значение `key` должно быть уникальным среди братьев-сестер (siblings). Чаще всего используются уникальные идентификаторы из данных (например, `id`).
  - **Постоянство:** Значение `key` должно быть постоянным между рендерами. Не используйте индексы массива в качестве `key`, если порядок элементов может измениться, так как это может привести к некорректному поведению.

  ### Пример проблемы с использованием индексов массива в качестве `key`:

  ```jsx
  {
    items.map((item, index) => <li key={index}>{item.name}</li>);
  }
  ```

  Если порядок элементов в `items` изменится (например, при сортировке), React может неправильно понять, какие элементы были изменены, так как индексы будут оставаться теми же, хотя сами элементы могут поменяться местами. Это может привести к неправильному отображению данных или другим непредсказуемым последствиям.

  ### Заключение:

  Атрибут `key` играет важную роль в рендеринге списков в React. Он помогает React правильно отслеживать изменения в списке и эффективно обновлять DOM, избегая лишних операций. Всегда выбирайте уникальные и постоянные значения для `key`, чтобы гарантировать правильное и предсказуемое поведение вашего приложения.

- Вопрос [Что такое `PureComponent`?]()

  - Ответ[`PureComponent` - это специальный компонент в React, который реализует метод `shouldComponentUpdate` с поверхностным (shallow) сравнением свойств (props) и состояния (state). В отличие от обычного компонента (`Component`), `PureComponent` автоматически выполняет эту проверку и решает, стоит ли компоненту обновляться.

  Основное отличие между `Component` и `PureComponent` заключается в том, что `PureComponent` автоматически выполняет проверку на изменения свойств и состояния, и если эти изменения не затрагивают компонент, он не будет перерисовываться. Это может повысить производительность в некоторых случаях, так как избегается избыточное обновление компонента.

  Пример использования `PureComponent`:

  ```jsx
  import React, { PureComponent } from 'react';

  class MyComponent extends PureComponent {
    render() {
      return <div>{this.props.value}</div>;
    }
  }
  ```

  В данном примере, если компонент `MyComponent` обновляется и ему передаются новые свойства (`value`), `PureComponent` автоматически проверит, изменились ли эти свойства по сравнению с предыдущими значениями, и решит, нужно ли обновление компонента.

  Важно отметить, что `PureComponent` использует поверхностное сравнение (shallow comparison) для объектов и массивов, поэтому если ваши свойства или состояние содержат вложенные структуры данных, изменения внутри этих структур могут быть пропущены, и компонент не будет обновлен. В таких случаях, вам может потребоваться использовать дополнительные методы для глубокого сравнения или использовать обычный `Component` с ручной реализацией `shouldComponentUpdate`, если это более удобно.]()

- Вопрос [Чем отличается useMemo от useCallback]()

  - Ответ[`useMemo` и `useCallback` в React используются для оптимизации производительности при работе с функциональными компонентами и мемоизации значений. Однако, они применяются в разных контекстах и решают разные задачи:

  1. **`useMemo`:**

  - **Цель:** `useMemo` используется для мемоизации результатов вычислений и предотвращения повторного вычисления значения при каждом рендере компонента.
  - **Когда использовать:** Используется, когда вам нужно вычислить и сохранить результат какого-то выражения (например, результат сложения или фильтрации массива) и предотвратить повторное вычисление при каждом рендере компонента.
  - **Пример:**
    ```jsx
    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
    ```

  2. **`useCallback`:**

  - **Цель:** `useCallback` используется для мемоизации колбэк-функций и предотвращения их повторного создания при каждом рендере компонента.
  - **Когда использовать:** Используется, когда вам нужно передавать колбэк-функции в дочерние компоненты, и вы хотите предотвратить лишние рендеры дочерних компонентов при изменении родительского компонента.
  - **Пример:**
    ```jsx
    const handleClick = useCallback(
      () => {
        // Обработка клика
      },
      [
        /* зависимости */
      ]
    );
    ```

  **Общие черты:**

  - Оба хука принимают вторым аргументом массив зависимостей. Этот массив указывает, когда нужно повторно вычислить значение (в случае `useMemo`) или создать новую колбэк-функцию (в случае `useCallback`).
  - Оба помогают предотвратить ненужные вычисления или создания функций, что может улучшить производительность компонентов.

  **Различия:**

  - `useMemo` возвращает мемоизированное значение, тогда как `useCallback` возвращает мемоизированную колбэк-функцию.
  - `useMemo` используется для мемоизации значений, а `useCallback` - для мемоизации колбэк-функций.
  - `useMemo` полезен, когда вы хотите избежать повторных вычислений значений, тогда как `useCallback` - когда вы хотите избежать повторного создания функций.]()

- Вопрос [Разница между теневым (Shadow) и виртуальным (Virtual) DOM?]()

  - Ответ[
    **Виртуальный DOM (Virtual DOM)**
    Виртуальный DOM — это концепция оптимизации процесса обновления реального DOM в веб-приложениях. Он представляет собой виртуальное представление текущего состояния DOM в виде дерева объектов. Вместо того чтобы напрямую взаимодействовать с реальным DOM при каждом изменении данных, библиотеки, такие как React, используют виртуальный DOM для вычисления минимальных изменений, которые необходимо внести в реальный DOM.

    Процесс работает примерно так:

    1. Изменения данных в вашем приложении приводят к созданию нового виртуального DOM.
    2. Новый виртуальный DOM сравнивается с предыдущим состоянием виртуального DOM.
    3. Вычисляются минимальные изменения (разница между новым и старым виртуальными DOM).
    4. Только эти минимальные изменения применяются к реальному DOM.

    Такой подход уменьшает количество манипуляций с реальным DOM, что ведет к улучшению производительности.

    **Теневой DOM (Shadow DOM):**

    Теневой DOM — это технология, предоставляющая изолированное DOM-дерево и стили для компонентов веб-приложения. Он позволяет создавать компоненты с их собственными стилями и структурами, которые изолированы от внешнего DOM. Это особенно полезно для создания переиспользуемых компонентов и веб-компонентов.

    Ключевые особенности теневого DOM:

    1. **Изоляция стилей:** Стили, определенные в теневом DOM, не затрагивают стили внешнего DOM, и наоборот.
    2. **Изолированная область видимости:** Элементы в теневом DOM видны только внутри этого теневого DOM, что предотвращает конфликты имен и стилей с внешним DOM.
    3. **Компоненты с теневым DOM:** Технология теневого DOM часто используется в создании веб-компонентов для обеспечения изоляции и управления стилями компонентов.

    **Вывод:**
    Оба концепта, виртуальный DOM и теневой DOM, направлены на улучшение производительности и структуризацию кода в веб-приложениях. Виртуальный DOM оптимизирует процесс обновления реального DOM, а теневой DOM обеспечивает изоляцию стилей и DOM для компонентов. Иногда эти термины могут использоваться в разных контекстах и технологиях.

    **Теневой DOM (Shadow DOM):**

    Теневой DOM представляет собой технологию, позволяющую создавать изолированные компоненты с их собственными стилями и структурами веб-приложения. Он обеспечивает изоляцию и скрытность вложенных компонентов от внешнего DOM (основного DOM-дерева).

    Основные концепции и функции теневого DOM:

    1. **Изоляция стилей:** Стили, определенные внутри теневого DOM, не влияют на стили внешнего DOM и наоборот. Это позволяет компонентам иметь свои уникальные стили, не создавая конфликтов с остальной частью приложения.

    2. **Изолированная область видимости:** Элементы внутри теневого DOM видны только внутри этого теневого DOM. Компоненты могут содержать свои собственные элементы, которые не пересекаются с элементами внешнего DOM, что способствует изоляции и уменьшению возможных конфликтов.

    3. **Сокрытие деталей реализации:** Теневой DOM предоставляет средства для сокрытия деталей реализации компонентов от внешнего кода. Это способствует созданию чистого API для использования компонентов.

    Пример использования теневого DOM:

    ```html
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <style>
          /* Стили внешнего DOM */
          div {
            color: red;
          }
        </style>
      </head>
      <body>
        <div id="app"></div>

        <script>
          const shadowRoot = document.getElementById('app').attachShadow({ mode: 'open' });

          // HTML и стили внутри теневого DOM
          shadowRoot.innerHTML = `
          <style>
            div {
              color: blue;
            }
          </style>
          <div>Hello, Shadow DOM!</div>
        `;
        </script>
      </body>
    </html>
    ```

    В этом примере `<div>Hello, Shadow DOM!</div>` находится внутри теневого DOM, и его стили (синий цвет) изолированы от стилей внешнего DOM (красный цвет).

    **Разница Теневой DOM (Shadow DOM) / Виртуальный DOM (Virtual DOM)**

    1. **Область видимости:**

       - Теневой DOM предоставляет изолированную область видимости и стилей для компонентов. Это означает, что стили и DOM элементы внутри теневого DOM не влияют на стили и элементы в основном DOM и наоборот.

    2. **Изоляция стилей:**

       - Стили, определенные в теневом DOM, ограничены областью видимости этого теневого DOM. Это позволяет компонентам иметь свои уникальные стили без влияния на стили внешнего DOM.

    3. **Компоненты с теневым DOM:**

       - Теневой DOM часто используется в веб-компонентах для создания изолированных и переиспользуемых компонентов.

    **Виртуальный DOM (Virtual DOM):**

    1. **Концепция перерисовки:**

       - Виртуальный DOM представляет собой виртуальное представление текущего состояния реального DOM. Он используется для оптимизации процесса перерисовки и обновления DOM.

    2. **Эффективные обновления:**

       - Вместо непосредственного изменения реального DOM при каждом обновлении данных, React (и другие библиотеки) использует виртуальный DOM для вычисления минимального количества изменений и эффективного обновления реального DOM.

    3. **Реконсиляция:**

       - Процесс сравнения виртуального DOM с предыдущим состоянием и применения минимальных изменений для обновления реального DOM называется реконсиляцией.

    **Общее:**

    1. **Эффективность:**

       - Оба подхода направлены на улучшение производительности веб-приложений, хотя решают разные проблемы. Теневой DOM решает проблему изоляции компонентов, а виртуальный DOM — проблему эффективной перерисовки DOM.

    2. **Использование:**

       - Теневой DOM используется чаще в контексте веб-компонентов и Shadow DOM API, тогда как виртуальный DOM чаще ассоциируется с библиотеками, такими как React, для эффективного управления обновлениями DOM.

    В целом, теневой DOM и виртуальный DOM представляют различные концепции, и каждый из них решает свои специфические задачи в области разработки веб-приложений.

    ]()

- Вопрос [Что такое портал (`Portal`)?]()

  - Ответ[Портал (`Portal`) в React - это механизм, который позволяет рендерить дочерние элементы в DOM-узлы, которые находятся вне иерархии родительских компонентов. Это полезно, когда вам нужно отрендерить содержимое в другое место в DOM, не меняя свою иерархию компонентов.

  Чтобы использовать портал, вы можете использовать компонент `ReactDOM.createPortal(child, container)`. `child` - это React-элемент, который вы хотите отрендерить, а `container` - DOM-элемент, в который вы хотите его поместить.

  Пример:

  ```jsx
  import React, { useState } from 'react';
  import ReactDOM from 'react-dom';

  const Modal = ({ children, onClose }) => {
    const modalRoot = document.getElementById('modal-root');
    const el = document.createElement('div');

    React.useEffect(() => {
      modalRoot.appendChild(el);
      return () => modalRoot.removeChild(el);
    }, [el, modalRoot]);

    return ReactDOM.createPortal(
      <div className="modal">
        {children}
        <button onClick={onClose}>Close</button>
      </div>,
      el
    );
  };

  const App = () => {
    const [modalIsOpen, setModalIsOpen] = useState(false);

    return (
      <div>
        <button onClick={() => setModalIsOpen(true)}>Open Modal</button>
        {modalIsOpen && (
          <Modal onClose={() => setModalIsOpen(false)}>
            <p>Modal content goes here.</p>
          </Modal>
        )}
      </div>
    );
  };

  ReactDOM.render(<App />, document.getElementById('root'));
  ```

  В этом примере `Modal` - это компонент, который рендерит содержимое внутри портала. Портал создается с использованием `createPortal` и помещает содержимое в отдельный DOM-элемент, который добавляется к элементу с id `modal-root` внутри DOM. Это позволяет модальному окну отрендериться вне своего родительского компонента, сохраняя при этом структуру DOM-дерева вашего приложения.]()

- Вопрос [Разница между теневым (Shadow) и виртуальным (Virtual) DOM?]()

  - Ответ[Теневой DOM (Shadow DOM) и виртуальный DOM (Virtual DOM) - это два концептуально разных подхода, используемых в веб-разработке, но оба направлены на оптимизацию и эффективность обновления пользовательского интерфейса. Давайте рассмотрим разницу между ними:

  ### Теневой DOM (Shadow DOM):

  1. **Изоляция компонентов:** Shadow DOM предоставляет механизм для создания изолированных компонентов с их собственным DOM-деревом, стилями и логикой. Компоненты, находящиеся внутри Shadow DOM, изолированы от основного DOM документа.

  2. **Создание "тени":** Элементы, находящиеся внутри Shadow DOM, создают так называемую "тень" (shadow), что позволяет стилям и событиям внутри Shadow DOM не влиять на элементы вне него и наоборот.

  3. **Сокрытие реализации:** Shadow DOM предназначен для сокрытия внутренней реализации компонента, что позволяет разработчикам создавать более чистый и управляемый интерфейс.

  ### Виртуальный DOM (Virtual DOM):

  1. **Репрезентация в памяти:** Виртуальный DOM - это представление DOM в памяти. Это облегчает манипуляцию и манипуляции с DOM без прямого воздействия на браузер.

  2. **Эффективные обновления:** При изменении состояния компонента в React или других библиотеках с виртуальным DOM, создается новое виртуальное дерево, которое сравнивается с предыдущим состоянием. Только измененные части передаются в реальный DOM, что делает процесс обновления более эффективным.

  3. **Батч-операции:** Виртуальный DOM позволяет проводить батч-операции. Все изменения в виртуальном DOM собираются вместе, и только после этого происходит фактическое воздействие на реальный DOM, что уменьшает количество перерисовок и повышает производительность.

  ### Сравнение:

  - **Применение:** Shadow DOM применяется для создания изолированных компонентов с их собственным DOM-деревом, тогда как виртуальный DOM используется для оптимизации процесса обновления реального DOM.

  - **Цель:** Shadow DOM обеспечивает изоляцию и инкапсуляцию компонентов, а виртуальный DOM - эффективные обновления и управление процессом рендеринга.

  В целом, теневой DOM и виртуальный DOM решают разные задачи в контексте веб-разработки и могут использоваться в комбинации для достижения лучшей производительности и управляемости кода.]()

- Вопрос [Что такое React Reconciliation?]()

  - Ответ[React Reconciliation (согласование в React) - это процесс сравнения и обновления элементов пользовательского интерфейса в библиотеке React. Когда состояние компонентов React изменяется, React сравнивает текущее дерево компонентов с предыдущим состоянием и определяет, какие части интерфейса нужно обновить, чтобы отобразить новое состояние.

  Основные идеи и понятия, связанные с согласованием в React:

  1. Виртуальный DOM (Virtual DOM): React использует виртуальный DOM для представления дерева компонентов. Это абстрактное представление реальных элементов интерфейса, которое React может быстро сравнивать с предыдущей версией виртуального DOM.

  2. Сравнение элементов: React сравнивает каждый элемент в новом виртуальном DOM с соответствующим элементом в предыдущем виртуальном DOM. React определяет, были ли внесены изменения в какие-либо элементы.

  3. Реконсиляция (Reconciliation): Если React обнаруживает, что элементы изменились, он проводит процесс реконсиляции, который включает в себя добавление, обновление или удаление соответствующих элементов в реальном DOM, чтобы отобразить новое состояние приложения.

  4. Ключи (Keys): React использует ключи, предоставляемые разработчиками, чтобы уникально идентифицировать элементы в списке. Ключи помогают React определить, какие элементы были добавлены, удалены или перемещены внутри списка.

  5. Эффективность: Процесс реконсиляции React нацелен на оптимизацию производительности. React старается минимизировать количество манипуляций с реальным DOM, фокусируясь на изменениях, которые действительно нужно внести.

  Процесс согласования в React является ключевой частью его механизма работы и позволяет разработчикам создавать интерактивные и быстрые веб-приложения, даже при изменении состояния и обновлении пользовательского интерфейса. Этот процесс делает React эффективным и обеспечивает быструю отрисовку компонентов.]()

- Вопрос [Что такое Компонент высшего порядка (Higher-Order Component/HOC)?]()
  **Компонент высшего порядка (Higher-Order Component, HOC)** — это продвинутая техника в React для повторного использования логики между компонентами. HOC представляет собой функцию, которая принимает компонент в качестве аргумента и возвращает новый компонент с добавленной функциональностью.

  ### Основные особенности HOC:

  1. **Повторное использование логики:**

  - HOC позволяет вынести повторяющуюся логику, которая используется в нескольких компонентах, в одно место. Например, если нужно добавить функциональность авторизации, логгирования или управления состоянием, это можно сделать с помощью HOC.

  2. **Функция, принимающая и возвращающая компонент:**

  - HOC — это функция, которая принимает компонент и возвращает новый компонент с расширенной функциональностью. Это похоже на концепцию функции высшего порядка в функциональном программировании, где функция принимает другую функцию в качестве аргумента или возвращает её.

  3. **Не изменяет исходный компонент:**

  - Важно отметить, что HOC не изменяет и не мутирует исходный компонент. Вместо этого он создаёт новый компонент, который оборачивает исходный компонент, добавляя к нему новую функциональность.

  4. **Пример использования:**

  - HOC часто используются для инкапсуляции поведения, которое нужно применять к нескольким компонентам, например, работа с данными, авторизация, логирование или обработка ошибок.

  ### Пример создания HOC:

  Предположим, у нас есть задача — отображать компонент только для авторизованных пользователей. Можно создать HOC, который добавит эту функциональность:

  ```jsx
  import React from 'react';

  // HOC, который проверяет, авторизован ли пользователь
  function withAuth(WrappedComponent) {
    return class extends React.Component {
      render() {
        const isAuthenticated = /* логика проверки авторизации */;

        if (!isAuthenticated) {
          return <div>Access denied. Please log in.</div>;
        }

        return <WrappedComponent {...this.props} />;
      }
    };
  }

  // Обычный компонент
  function Dashboard(props) {
    return <h1>Welcome to the dashboard, {props.userName}!</h1>;
  }

  // Используем HOC для создания компонента с добавленной функциональностью
  const ProtectedDashboard = withAuth(Dashboard);

  // Использование ProtectedDashboard в приложении
  export default function App() {
    return <ProtectedDashboard userName="John Doe" />;
  }
  ```

  ### В этом примере:

  - `withAuth` — это HOC, который оборачивает компонент `Dashboard` и добавляет логику проверки авторизации.
  - Если пользователь не авторизован, HOC отображает сообщение о необходимости входа в систему.
  - Если пользователь авторизован, HOC передает все пропсы (`props`) компоненту `Dashboard` и рендерит его.

  ### Применение HOC:

  - **Оборачивание компонентов для подключения к глобальному состоянию (например, Redux).**
  - **Добавление общих данных или поведения к множеству компонентов.**
  - **Обработка ошибок или логирование.**

  ### Ограничения и альтернативы:

  - **Наследование пропсов:** Иногда HOC могут приводить к утечке абстракции, когда становится сложно понять, откуда приходят определенные пропсы.
  - **Перенос контекста:** HOC не могут напрямую передавать `ref` на оборачиваемый компонент, поэтому часто используют `React.forwardRef`.
  - **Альтернативы:** В некоторых случаях хуки (React Hooks) могут быть более подходящей альтернативой для повторного использования логики между компонентами, особенно когда речь идет о функциональных компонентах.

  ### Заключение:

  Компоненты высшего порядка (HOC) — это мощный инструмент в React, который позволяет разделять и повторно использовать логику между различными компонентами. Они помогают делать код более модульным и поддерживаемым, особенно в крупных приложениях. Однако их следует использовать с пониманием возможных ограничений и альтернатив, таких как хуки.

- Вопрос [Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?]()
  В React компоненты могут быть управляемыми (controlled) или не управляемыми (uncontrolled) в зависимости от того, как они управляют своим состоянием и взаимодействуют с данными формы. Оба подхода имеют свои особенности и применяются в разных сценариях.

  ### Управляемые компоненты (Controlled Components)

  **Управляемый компонент** — это компонент, в котором состояние формы (например, значение текстового поля) полностью контролируется React. В таком компоненте значение элемента формы хранится в состоянии компонента (`state`), и изменения значения обрабатываются через события, такие как `onChange`.

  #### Основные особенности:

  1. **Состояние хранится в React:** Значение элемента формы хранится в `state` компонента, и любое изменение этого значения происходит через обновление состояния.
  2. **Однонаправленный поток данных:** Поскольку состояние компонента контролируется React, любые изменения вводятся через `props` или события, что делает данные предсказуемыми и легкими для отслеживания.
  3. **Легкость валидации и обработки данных:** Поскольку данные формы находятся в `state`, их легко валидировать, фильтровать или изменять перед отправкой на сервер.

  #### Пример управляемого компонента:

  ```jsx
  import React, { useState } from 'react';

  function ControlledInput() {
    const [value, setValue] = useState('');

    const handleChange = (event) => {
      setValue(event.target.value);
    };

    return <input type="text" value={value} onChange={handleChange} />;
  }
  ```

  В этом примере значение инпута (`value`) хранится в состоянии компонента, и любое изменение вводится через обработчик `handleChange`, который обновляет состояние с помощью `setValue`.

  ### Неуправляемые компоненты (Uncontrolled Components)

  **Неуправляемый компонент** — это компонент, в котором состояние формы управляется непосредственно DOM-элементом, а не React. Вместо использования `state` для хранения значения элемента формы, доступ к значению осуществляется через `ref`, который предоставляет доступ к DOM-элементу напрямую.

  #### Основные особенности:

  1. **Состояние хранится в DOM:** Значение элемента формы хранится в самом DOM-элементе, а не в состоянии компонента.
  2. **Использование `ref`:** Для доступа к значению формы используется `ref`. Например, чтобы получить значение инпута, можно обратиться к нему через `ref.current.value`.
  3. **Подходит для простых форм:** Неуправляемые компоненты проще использовать в ситуациях, когда не требуется сложная логика управления состоянием или валидации.

  #### Пример неуправляемого компонента:

  ```jsx
  import React, { useRef } from 'react';

  function UncontrolledInput() {
    const inputRef = useRef(null);

    const handleSubmit = (event) => {
      event.preventDefault();
      alert('Input value: ' + inputRef.current.value);
    };

    return (
      <form onSubmit={handleSubmit}>
        <input type="text" ref={inputRef} />
        <button type="submit">Submit</button>
      </form>
    );
  }
  ```

  В этом примере значение инпута не хранится в `state`, а вместо этого доступно через `ref` (`inputRef.current.value`), когда нужно получить его значение.

  ### Основные различия:

  | Характеристика                 | Управляемые компоненты (Controlled)              | Неуправляемые компоненты (Uncontrolled)          |
  | ------------------------------ | ------------------------------------------------ | ------------------------------------------------ |
  | Хранение состояния             | В `state` компонента, контролируется React       | В DOM-элементе, доступ через `ref`               |
  | Изменение значения             | Через обновление состояния и обработчики событий | Через прямое взаимодействие с DOM через `ref`    |
  | Управление данными и валидация | Легко управлять и валидировать данные            | Менее удобно, так как данные управляются DOM     |
  | Использование                  | Подходит для сложных форм с логикой и валидацией | Подходит для простых форм или одноразового ввода |

  ### Заключение:

  Управляемые и неуправляемые компоненты — это два подхода к работе с формами в React. Управляемые компоненты обеспечивают полный контроль над состоянием и данными, что делает их идеальными для сложных форм с необходимостью валидации. Неуправляемые компоненты предлагают более простой подход, полагаясь на встроенный в браузер механизм управления формами, и могут быть полезны в простых сценариях или при работе с большими объемами данных, где перерисовка состояния может быть дорогой.

- Вопрос [Методы жизненного цикла компонента в React?]()
  Методы жизненного цикла компонента в React позволяют разработчикам управлять поведением компонентов на различных этапах их существования: создание, обновление и удаление. В React есть два типа компонентов: классовые и функциональные. Методы жизненного цикла традиционно ассоциируются с классовыми компонентами, но с введением хуков функциональные компоненты также могут управлять своим жизненным циклом.

  ### Жизненный цикл классовых компонентов

  1. **Монтирование (Mounting):**

  - Эти методы вызываются один раз, когда компонент впервые добавляется в DOM.

  - **`constructor(props)`**:

    - Инициализирует состояние и привязывает методы компонента. Вызывается перед монтированием компонента.

  - **`static getDerivedStateFromProps(nextProps, prevState)`**:

    - Вызывается перед каждым рендером (как во время монтирования, так и обновления). Используется для обновления состояния на основе изменений пропсов. Возвращает объект состояния или `null`.

  - **`render()`**:

    - Обязательный метод, который возвращает JSX-элемент, представляющий пользовательский интерфейс компонента.

  - **`componentDidMount()`**:
    - Вызывается сразу после монтирования компонента в DOM. Здесь можно выполнять побочные эффекты, такие как запросы к API или настройка подписок.

  2. **Обновление (Updating):**

  - Эти методы вызываются каждый раз, когда изменяются пропсы или состояние компонента.

  - **`static getDerivedStateFromProps(nextProps, prevState)`**:

    - Описан выше. Вызывается перед каждым обновлением.

  - **`shouldComponentUpdate(nextProps, nextState)`**:

    - Используется для оптимизации производительности. Возвращает `true` или `false`, определяя, нужно ли перерисовывать компонент. По умолчанию возвращает `true`.

  - **`render()`**:

    - Описан выше. Вызывается при каждом обновлении.

  - **`getSnapshotBeforeUpdate(prevProps, prevState)`**:

    - Вызывается прямо перед тем, как изменённый компонент отрендерится в DOM. Возвращает значение, которое затем передаётся в `componentDidUpdate`.

  - **`componentDidUpdate(prevProps, prevState, snapshot)`**:
    - Вызывается сразу после обновления компонента. Здесь можно выполнять побочные эффекты, такие как запросы к API на основе новых пропсов или состояния.

  3. **Размонтирование (Unmounting):**

  - Эти методы вызываются один раз, когда компонент удаляется из DOM.

  - **`componentWillUnmount()`**:
    - Вызывается перед удалением компонента из DOM. Здесь следует отменить подписки, таймеры или очистить другие ресурсы.

  4. **Обработка ошибок (Error Handling):**

  - Эти методы используются для обработки ошибок, произошедших во время рендеринга, в методах жизненного цикла или в конструкторах дочерних компонентов.

  - **`static getDerivedStateFromError(error)`**:

    - Вызывается при возникновении ошибки в одном из дочерних компонентов. Позволяет обновить состояние для отображения резервного интерфейса.

  - **`componentDidCatch(error, info)`**:
    - Вызывается после возникновения ошибки. Здесь можно логировать ошибки или выполнять другие действия по их обработке.

  ### Жизненный цикл функциональных компонентов с хуками

  В функциональных компонентах с введением хуков жизненный цикл управляется с помощью хуков, таких как `useEffect`, `useState`, `useLayoutEffect` и т.д.

  - **`useEffect(callback, dependencies)`**:

    - Комбинирует поведение методов `componentDidMount`, `componentDidUpdate` и `componentWillUnmount`.
    - Если массив зависимостей пуст (`[]`), эффект срабатывает только при монтировании и размонтировании компонента.
    - Если зависимости указаны, эффект срабатывает при изменении этих зависимостей.
    - Возвращаемая функция используется для очистки (аналог `componentWillUnmount`).

  - **`useLayoutEffect(callback, dependencies)`**:
    - Похож на `useEffect`, но вызывается синхронно после всех изменений DOM. Используется для операций, которые должны произойти до того, как браузер отрисует обновления.

  ### Пример жизненного цикла в классовом компоненте:

  ```jsx
  class MyComponent extends React.Component {
    constructor(props) {
      super(props);
      this.state = { count: 0 };
    }

    static getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.defaultCount !== prevState.count) {
        return { count: nextProps.defaultCount };
      }
      return null;
    }

    componentDidMount() {
      console.log('Component mounted');
    }

    shouldComponentUpdate(nextProps, nextState) {
      return nextState.count !== this.state.count;
    }

    componentDidUpdate(prevProps, prevState) {
      console.log('Component updated');
    }

    componentWillUnmount() {
      console.log('Component will unmount');
    }

    render() {
      return (
        <div>
          <p>Count: {this.state.count}</p>
          <button onClick={() => this.setState({ count: this.state.count + 1 })}>Increment</button>
        </div>
      );
    }
  }
  ```

  ### Пример жизненного цикла в функциональном компоненте:

  ```jsx
  import React, { useState, useEffect } from 'react';

  function MyComponent({ defaultCount }) {
    const [count, setCount] = useState(defaultCount);

    useEffect(() => {
      console.log('Component mounted or updated');
      return () => {
        console.log('Component will unmount');
      };
    }, [count]);

    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
      </div>
    );
  }
  ```

  ### Заключение:

  Методы жизненного цикла в React позволяют управлять поведением компонентов на различных этапах их существования. В классовых компонентах для этого используются методы, такие как `componentDidMount`, `componentDidUpdate`, и `componentWillUnmount`. В функциональных компонентах аналогичные задачи решаются с помощью хуков, таких как `useEffect`. Знание жизненного цикла компонентов помогает создавать более эффективные, оптимизированные и поддерживаемые React-приложения.

- Вопрос [Стадии жизненного цикла компонента в React?]()
  Жизненный цикл компонента в React включает несколько стадий, которые определяют последовательность событий от момента создания компонента до его удаления. Эти стадии помогают управлять поведением компонента на разных этапах его существования.

  ### Основные стадии жизненного цикла компонента:

  1. **Монтирование (Mounting):**

  - **Описание:** Это начальная стадия, когда компонент создается и добавляется в DOM. В этой стадии происходит инициализация состояния и рендеринг компонента.
  - **Методы:**
    - `constructor(props)` — Инициализация компонента. Используется для установки начального состояния и привязки методов.
    - `static getDerivedStateFromProps(nextProps, prevState)` — Позволяет обновить состояние на основе изменений в пропсах перед рендером.
    - `render()` — Возвращает JSX-разметку для отображения компонента.
    - `componentDidMount()` — Вызывается сразу после монтирования компонента в DOM. Используется для выполнения побочных эффектов, таких как запросы к API или настройка подписок.

  2. **Обновление (Updating):**

  - **Описание:** Эта стадия наступает, когда компонент получает новые пропсы или его состояние изменяется. Во время этой стадии React решает, нужно ли обновлять компонент.
  - **Методы:**
    - `static getDerivedStateFromProps(nextProps, prevState)` — Вызывается перед каждым обновлением, позволяет обновить состояние на основе изменений в пропсах.
    - `shouldComponentUpdate(nextProps, nextState)` — Определяет, нужно ли перерисовывать компонент при изменении пропсов или состояния. Может использоваться для оптимизации производительности.
    - `render()` — Перерисовывает компонент на основе новых пропсов или состояния.
    - `getSnapshotBeforeUpdate(prevProps, prevState)` — Вызывается прямо перед обновлением компонента в DOM. Позволяет сохранить информацию, которая может понадобиться после обновления.
    - `componentDidUpdate(prevProps, prevState, snapshot)` — Вызывается сразу после обновления компонента в DOM. Используется для выполнения побочных эффектов на основе предыдущих пропсов или состояния.

  3. **Размонтирование (Unmounting):**

  - **Описание:** Это финальная стадия жизненного цикла компонента, когда компонент удаляется из DOM.
  - **Метод:**
    - `componentWillUnmount()` — Вызывается перед удалением компонента из DOM. Используется для очистки ресурсов, отмены подписок и таймеров.

  4. **Обработка ошибок (Error Handling):**

  - **Описание:** Эта стадия активируется, когда в процессе рендеринга, в методах жизненного цикла или конструкторах дочерних компонентов возникает ошибка.
  - **Методы:**
    - `static getDerivedStateFromError(error)` — Вызывается при возникновении ошибки. Позволяет обновить состояние для отображения резервного интерфейса.
    - `componentDidCatch(error, info)` — Вызывается после возникновения ошибки. Используется для логирования ошибок и выполнения других действий по их обработке.

  ### Стадии жизненного цикла на практике:

  #### Монтирование:

  - **`constructor` → `getDerivedStateFromProps` → `render` → `componentDidMount`**

  Пример:

  ```jsx
  class MyComponent extends React.Component {
    constructor(props) {
      super(props);
      this.state = { data: null };
    }

    componentDidMount() {
      fetch('/api/data')
        .then((response) => response.json())
        .then((data) => this.setState({ data }));
    }

    render() {
      return <div>{this.state.data ? this.state.data : 'Loading...'}</div>;
    }
  }
  ```

  #### Обновление:

  - **`getDerivedStateFromProps` → `shouldComponentUpdate` → `render` → `getSnapshotBeforeUpdate` → `componentDidUpdate`**

  Пример:

  ```jsx
  class MyComponent extends React.Component {
    componentDidUpdate(prevProps) {
      if (this.props.id !== prevProps.id) {
        this.fetchData(this.props.id);
      }
    }

    fetchData(id) {
      // Логика для получения данных по новому id
    }

    render() {
      return <div>Data for ID: {this.props.id}</div>;
    }
  }
  ```

  #### Размонтирование:

  - **`componentWillUnmount`**

  Пример:

  ```jsx
  class MyComponent extends React.Component {
    componentWillUnmount() {
      clearInterval(this.timer);
    }

    render() {
      return <div>Component is mounted</div>;
    }
  }
  ```

  ### Заключение:

  Стадии жизненного цикла компонента в React — это последовательность событий, которые происходят с компонентом от момента его создания до удаления. Понимание этих стадий и соответствующих методов помогает эффективно управлять состоянием, производительностью и поведением компонентов на всех этапах их существования.

- Вопрос [Что такое контекст (`Context`)?]()
  **Контекст (Context)** в React — это инструмент, который позволяет передавать данные через дерево компонентов без необходимости явно передавать пропсы на каждом уровне. Это особенно полезно, когда нужно предоставить данные или функциональность множеству компонентов на разных уровнях иерархии, избегая так называемого "пробрасывания пропсов" (prop drilling).

  ### Основные особенности и использование контекста:

  1. **Передача данных через дерево компонентов:**

  - Контекст позволяет передавать значения (например, текущую тему, язык интерфейса, настройки пользователя) непосредственно компонентам, находящимся глубоко в дереве, без необходимости передавать эти значения через каждый промежуточный компонент.

  2. **Создание контекста:**

  - Контекст создается с помощью функции `React.createContext()`, которая возвращает объект контекста с двумя компонентами: `Provider` и `Consumer`.
  - **`Provider`** — компонент, который предоставляет значение контекста. Он оборачивает те компоненты, которым это значение должно быть доступно.
  - **`Consumer`** — компонент, который использует значение контекста. Он оборачивает тот компонент, который будет потреблять значение из контекста.

  3. **Пример создания и использования контекста:**

  ```jsx
  import React, { createContext, useContext, useState } from 'react';

  // Создание контекста
  const ThemeContext = createContext();

  // Компонент-поставщик (Provider)
  function ThemeProvider({ children }) {
    const [theme, setTheme] = useState('light');

    return <ThemeContext.Provider value={{ theme, setTheme }}>{children}</ThemeContext.Provider>;
  }

  // Компонент-потребитель (Consumer)
  function ThemedButton() {
    const { theme, setTheme } = useContext(ThemeContext);

    return (
      <button
        style={{
          backgroundColor: theme === 'light' ? '#fff' : '#333',
          color: theme === 'light' ? '#000' : '#fff',
        }}
        onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
      >
        Toggle Theme
      </button>
    );
  }

  // Пример использования
  function App() {
    return (
      <ThemeProvider>
        <ThemedButton />
      </ThemeProvider>
    );
  }

  export default App;
  ```

  В этом примере:

  - **`ThemeContext`** — контекст, который хранит информацию о текущей теме (`light` или `dark`).
  - **`ThemeProvider`** — компонент, который предоставляет значение темы и функцию для её изменения всем дочерним компонентам.
  - **`ThemedButton`** — компонент, который потребляет значение темы и изменяет её при нажатии на кнопку, используя контекст через `useContext`.

  4. **Когда использовать контекст:**

  - Контекст полезен, когда одно и то же значение требуется многим компонентам на разных уровнях иерархии, например, тема, текущий пользователь, языковые настройки.
  - Однако, его не рекомендуется использовать для каждой мелочи, так как это может привести к сложности отслеживания данных и их изменений.

  5. **Альтернативы контексту:**

  - Для более сложных сценариев управления состоянием (например, когда требуется много глобального состояния и логики), лучше использовать библиотеки управления состоянием, такие как Redux или MobX, которые предлагают более структурированный подход.

  ### Заключение:

  Контекст в React — это мощный инструмент для управления глобальными данными и их передачи через дерево компонентов. Он помогает избежать лишнего пробрасывания пропсов и упрощает управление такими аспектами приложения, как темы, языки, настройки пользователя и многое другое. Однако следует использовать контекст с осторожностью, чтобы не усложнить структуру приложения.

- [Что такое React хуки (Hooks)?]()
  **React хуки (Hooks)** — это функции, введённые в React с версии 16.8, которые позволяют использовать состояние и другие возможности React в функциональных компонентах. Ранее для управления состоянием и использования жизненных циклов компонентов требовалось создавать классовые компоненты, но с появлением хуков функциональные компоненты стали намного мощнее и гибче.

  ### Основные хуки

  1. **useState**:

  - Позволяет добавлять состояние в функциональный компонент.
  - Возвращает пару: текущее состояние и функцию для его обновления.
  - Пример:
    ```javascript
    const [count, setCount] = useState(0);
    ```
    Здесь `count` — текущее значение состояния, а `setCount` — функция для его обновления.

  2. **useEffect**:

  - Позволяет выполнять побочные эффекты в функциональных компонентах, такие как загрузка данных, подписка на события или изменения DOM.
  - По сути, это аналог методов жизненного цикла `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` в классовых компонентах.
  - Пример:
    ```javascript
    useEffect(() => {
      document.title = `Вы нажали ${count} раз`;
    }, [count]);
    ```
    Здесь эффект будет срабатывать каждый раз, когда изменяется `count`.

  3. **useContext**:

  - Позволяет использовать контекст в функциональных компонентах, делая его доступным в дереве компонентов без необходимости передавать данные через пропсы на каждом уровне.
  - Пример:
    ```javascript
    const value = useContext(MyContext);
    ```
    Здесь `MyContext` — это контекст, созданный с помощью `React.createContext`.

  ### Дополнительные хуки

  1. **useReducer**:

  - Более мощная альтернатива `useState`, особенно полезная при управлении сложными состояниями.
  - Работает аналогично редьюсерам в Redux.
  - Пример:
    ```javascript
    const [state, dispatch] = useReducer(reducer, initialState);
    ```

  2. **useMemo**:

  - Позволяет мемоизировать значения, которые зависят от вычислений, чтобы избежать лишних вычислений при каждом рендере.
  - Пример:
    ```javascript
    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
    ```

  3. **useCallback**:

  - Меморизирует функции, чтобы избежать их создания при каждом рендере, если зависимости не изменились.
  - Пример:
    ```javascript
    const memoizedCallback = useCallback(() => {
      doSomething(a, b);
    }, [a, b]);
    ```

  ### Правила использования хуков

  1. **Вызывать хуки только на верхнем уровне компонента**:

  - Нельзя использовать хуки внутри циклов, условий или вложенных функций. Хуки всегда должны быть вызваны в одном и том же порядке при каждом рендере.

  2. **Вызывать хуки только в функциональных компонентах или в пользовательских хуках**:

  - Нельзя использовать хуки в классовых компонентах или в любых обычных функциях.

  Хуки существенно упростили разработку на React, сделав код компонентов более чистым и логичным.

- [Что Такое `JSX`?]()
  **JSX (JavaScript XML)** — это синтаксическое расширение для JavaScript, используемое в React. Оно позволяет писать HTML-подобный код внутри JavaScript, который затем компилируется в обычные вызовы JavaScript-функций. JSX облегчает создание интерфейсов, делая код компонентов более читабельным и декларативным.

  ### Основные особенности JSX

  1. **Смешивание JavaScript и HTML-подобного синтаксиса**:

  - В JSX вы можете писать разметку, которая выглядит как HTML, но при этом она полностью интегрирована с JavaScript.
  - Пример:
    ```javascript
    const element = <h1>Hello, world!</h1>;
    ```
    Здесь `<h1>Hello, world!</h1>` — это JSX, который будет преобразован в вызов `React.createElement`.

  2. **Компоненты в JSX**:

  - JSX позволяет использовать компоненты как HTML-теги. Если компонент именуется с заглавной буквы, он считается пользовательским компонентом.
  - Пример:

    ```javascript
    const MyComponent = () => <div>My Component</div>;

    const App = () => <MyComponent />;
    ```

  3. **Вставка выражений в JSX**:

  - Внутри JSX можно использовать JavaScript-выражения, оборачивая их в фигурные скобки `{}`.
  - Пример:
    ```javascript
    const name = 'Roma';
    const element = <h1>Hello, {name}!</h1>;
    ```
    Здесь `name` будет заменено на строку `"Roma"`.

  4. **Атрибуты в JSX**:

  - Атрибуты в JSX работают так же, как и в HTML, но с некоторыми отличиями. Например, в JSX используется `className` вместо `class`, и `htmlFor` вместо `for`.
  - Пример:
    ```javascript
    const element = <div className="my-class">Content</div>;
    ```

  5. **Детали синтаксиса**:

  - В JSX теги должны быть закрыты: `<img src="image.jpg" />`.
  - Если тег пустой, его нужно закрывать с помощью `/`, как в примере выше.

  ### Как работает JSX

  Под капотом, JSX компилируется в обычные вызовы `React.createElement`, которые создают объектное представление элементов интерфейса (так называемые "React-элементы"). Эти элементы затем используются React для обновления интерфейса пользователя.

  Пример преобразования JSX в JavaScript:

  ```jsx
  const element = <h1>Hello, world!</h1>;
  ```

  Этот код компилируется в:

  ```javascript
  const element = React.createElement('h1', null, 'Hello, world!');
  ```

  ### Почему стоит использовать JSX

  1. **Читабельность и декларативность**:

  - JSX делает код более похожим на то, что вы видите в браузере, что упрощает понимание структуры компонентов.

  2. **Мощные возможности JavaScript**:

  - Поскольку JSX — это JavaScript, вы можете легко использовать переменные, функции, условия и циклы для генерации динамического контента.

  3. **Легкость интеграции**:

  - JSX позволяет легко объединять HTML и JavaScript, что делает процесс разработки компонентов более естественным и эффективным.

  JSX — это удобный инструмент для работы с интерфейсами в React, который позволяет сочетать мощь JavaScript с выразительностью HTML-подобного синтаксиса.

- [Разница между состоянием(`state`) и пропсами(`props`)?]()
  **Состояние (`state`) и пропсы (`props`)** — два ключевых концепта в React, которые используются для управления данными и поведением компонентов. Хотя они могут показаться похожими, их функциональные роли и способы использования различаются.

  ### 1. **Пропсы (`props`)**

  **Описание:**

  - Пропсы — это сокращение от "properties" (свойства). Они представляют собой входные данные, которые передаются в компонент извне, обычно от родительского компонента.
  - Пропсы являются неизменяемыми (immutable), то есть компонент не может изменять полученные пропсы. Это обеспечивает предсказуемость и чистоту компонентов.

  **Использование:**

  - Пропсы используются для передачи данных и коллбеков (функций) от родительских компонентов к дочерним.
  - С их помощью можно настроить компонент и сделать его более универсальным.

  **Пример:**

  ```javascript
  const Welcome = (props) => {
    return <h1>Hello, {props.name}!</h1>;
  };

  const App = () => {
    return <Welcome name="Roma" />;
  };
  ```

  Здесь `name="Roma"` передается как пропс в компонент `Welcome`, который использует его для отображения имени.

  ### 2. **Состояние (`state`)**

  **Описание:**

  - Состояние (state) представляет собой данные, которые управляются внутри компонента. В отличие от пропсов, состояние может изменяться, что позволяет компоненту реагировать на действия пользователя или другие изменения.
  - Состояние является изменяемым (mutable) и может обновляться через вызов функции `setState` (или аналогичных в хуках, например, `useState`).

  **Использование:**

  - Состояние используется для управления данными, которые могут изменяться с течением времени, например, ввод пользователя, состояние формы, или данные, загружаемые из API.
  - Когда состояние изменяется, React автоматически перерисовывает компонент, чтобы отобразить обновленные данные.

  **Пример:**

  ```javascript
  const Counter = () => {
    const [count, setCount] = useState(0);

    return (
      <div>
        <p>You clicked {count} times</p>
        <button onClick={() => setCount(count + 1)}>Click me</button>
      </div>
    );
  };
  ```

  Здесь `count` — это состояние, которое обновляется с помощью `setCount`. Каждое нажатие кнопки увеличивает счетчик.

  ### 3. **Основные различия**

  - **Источник данных:**

    - **Props:** передаются в компонент извне, обычно от родителя.
    - **State:** управляется и изменяется внутри самого компонента.

  - **Изменяемость:**

    - **Props:** неизменяемы. Компонент не может изменить свои пропсы.
    - **State:** изменяемо. Компонент может изменять свое состояние с помощью специальных функций, таких как `setState` или `useState`.

  - **Назначение:**
    - **Props:** используются для передачи данных между компонентами и настройки их поведения.
    - **State:** используется для хранения данных, которые могут изменяться в процессе работы компонента.

  ### 4. **Связь между пропсами и состоянием**

  - Иногда компонент может передавать часть своего состояния как пропс в дочерний компонент. Это позволяет создавать сложные структуры компонентов, где родитель управляет состоянием, а дочерние компоненты отображают данные на основе этих пропсов.
  - Например, состояние может быть управляемо на уровне контейнерного компонента, а пропсы передаваться в презентационные компоненты для отображения данных.

  **Заключение:**
  Пропсы и состояние играют разные роли в React-компонентах: пропсы позволяют передавать данные между компонентами, а состояние позволяет компоненту отслеживать и реагировать на изменения данных внутри него.

- [Что такое React Fiber?]()
  **React Fiber** — это новое архитектурное ядро React, представленное в версии React 16. Оно было создано для улучшения производительности и повышения гибкости React при работе с обновлениями пользовательского интерфейса. Fiber заменил старый алгоритм обновления (React Stack) и привнес новые возможности для более эффективного управления рендерингом компонентов.

  ### Основные особенности React Fiber:

  1. **Инкрементальный рендеринг**:

  - Одной из главных целей React Fiber является возможность разделять работу по рендерингу на небольшие части (инкременты) и выполнять их поэтапно. Это позволяет React более гибко распределять вычислительные задачи, особенно в случае больших и сложных интерфейсов.

  2. **Приоритет обновлений**:

  - React Fiber вводит систему приоритетов, позволяя различным типам обновлений получать разный приоритет в зависимости от их важности. Например, пользовательский ввод и анимации имеют более высокий приоритет, чем фоновые задачи, такие как загрузка данных.

  3. **Улучшенная поддержка анимаций и переходов**:

  - Благодаря инкрементальному рендерингу и приоритетам, React Fiber позволяет более плавно и эффективно управлять анимациями и переходами, не блокируя интерфейс тяжелыми вычислениями.

  4. **Возобновляемый рендеринг**:

  - Fiber позволяет приостанавливать и возобновлять работу по рендерингу. Если есть более важные задачи (например, ответ на действия пользователя), React может приостановить рендеринг, выполнить важную задачу, а затем вернуться к прерванной работе.

  5. **Управление стеком вызовов**:

  - В старом React Stack использовался рекурсивный алгоритм, который мог приводить к переполнению стека вызовов при глубокой иерархии компонентов. React Fiber избегает этой проблемы, используя итеративный подход, который лучше контролирует выполнение и предотвращает переполнение стека.

  ### Зачем нужен был React Fiber?

  До появления Fiber, React использовал подход, который мог приводить к длительным блокировкам интерфейса, особенно при сложных обновлениях. Это могло ухудшить пользовательский опыт, так как большие обновления интерфейса приводили к замедлению отклика на действия пользователя. Fiber решает эту проблему, делая React более гибким и способным обрабатывать сложные задачи рендеринга без ущерба для отзывчивости интерфейса.

  ### Как это влияет на разработчиков?

  Хотя React Fiber представляет собой значительное изменение внутренней архитектуры React, большинство разработчиков не нужно специально изменять свой код для использования Fiber. Однако знание Fiber помогает лучше понимать, как React управляет обновлениями, и как можно оптимизировать свои приложения, учитывая приоритеты и асинхронность обновлений.

  **Ключевые моменты**:

  - **Более плавная работа интерфейса** благодаря инкрементальному и приоритетному рендерингу.
  - **Улучшенная поддержка анимаций и пользовательских взаимодействий**.
  - **Гибкость в управлении рендерингом больших и сложных приложений**.

  Таким образом, React Fiber сделал React более мощным и адаптивным инструментом для создания высокопроизводительных пользовательских интерфейсов.

- [Что такое фрагмент (`Fragment`)? Почему фрагмент лучше, чем `div`?]()
- [Что такое синтетические события в React?]()
- [Что такое React-ссылка (`ref`)? Как создать ссылку?]()
- [Разница между теневым (Shadow) и виртуальным (Virtual) DOM?]()
- [Назовите преимущества использования React?]()
- [Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?]()
- [Что такое компонент-переключатель (Switching Component)?]()
- [Разница между `React` и `ReactDOM`?]()
- [Разница между компонентом и контейнером?]()
- [Как React обрабатывает, или ограничивает использование пропсов определенного типа?]()
- [Что такое строгий режим в React? Его преимущества?]()
- [Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?]()
- [Что такое «опрос» (Polling)? Как его реализовать в React?]()
- [Разница между элементом и компонентом?]()
- [Что такое `ReactDOMServer`?]()
- [Что такое предохранители (Error Boundaries)?]()
- [Что такое «ленивая» (Lazy) функция?]()
- [Разница между рендерингом и монтированием?]()
- [Что такое `сhildren`?]()
- [Что такое события указателя (Pointer Events)?]()
- [Что такое инверсия наследования (Inheritance Inversion)?]()
- [Как в React реализовать двустороннее связывание данных?]()
- [Разница между классовым и функциональным компонентами?]()
- [Разница между `useEffect()` и `componentDidMount()`?]()
- [Преимущества хуков?]()
- [Недостатки хуков?]()
- [Правила (ограничения) использования хуков?]()
- [Что такое поднятие состояния вверх (Lifting State Up)?]()
- [Что делает метод `shouldComponentUpdate`?]()
- [Разница между `createElement()` и `cloneElement()`?]()
- [Что такое `useReducer()`?]()
- [Как реализовать однократное выполнение операции при начальном рендеринге?]()
- [Что такое распределенный компонент?]()
- [Расскажите о хуках `useCallback()`, `useMemo()`, `useImperativeHandle()`, `useLayoutEffect()`?]()
- [Как отрендерить HTML код в React-компоненте?]()
- [Зачем в `setState()` нужно передавать функцию?]()
- [Для чего предназначен метод `registerServiceWorker()` в React?]()
- [Чем React Router отличается от обычной маршрутизации?]()
- [Какие хуки были добавлены в React Router версии 5?]()
- [Как передавать пропсы в React Router?]()
- [Что такое Reselect и как он работает?]()
- [Назовите основную цель React Fiber?]()
- [Какие типы данных может возвращать `render`?]()
- [Разница между `memo` и `useMemo`?]()
- [Что такое синтетические события (SyntheticEvent) в React?]()
- [Является ли React реактивным?]()
- [Техники оптимизации перфоманса React?]()
- [Лучшие практики безопасности в React?]()
