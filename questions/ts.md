<h3>
  <img src="../assets/TypeScript.png" width="16" height="16" />
  <span>TypeScript:</span>
</h3>

- [Что такое TypeScript?](https://youtu.be/R76_xPjzUd8?t=669)
- [Основные компоненты TypeScript?](https://youtu.be/R76_xPjzUd8?t=730)

- [Назовите особенности TypeScript?](https://youtu.be/R76_xPjzUd8?t=796)
- Вопрос [Основные компоненты TypeScript?]()

  - Ответ [TypeScript - это язык программирования, который представляет собой надмножество JavaScript, добавляющее статическую типизацию. Основными компонентами TypeScript являются:

  1. **Типы (Types):**

  - **Примитивные типы данных:** Например, `number`, `string`, `boolean`.
  - **Специальные типы:** Например, `any`, `void`, `null`, `undefined`, `never`.
  - **Объектные типы:** Включают `object` и пользовательские объекты.
  - **Функциональные типы:** Включают сигнатуры функций.

  Пример:

  ```typescript
  let age: number = 25;
  let name: string = 'John';
  let isValid: boolean = true;

  function add(x: number, y: number): number {
    return x + y;
  }
  ```

  2. **Интерфейсы (Interfaces):**

  - Интерфейсы представляют собой способ определения контрактов для объектов, что способствует обеспечению соответствия структур определенным ожиданиям.

  Пример:

  ```typescript
  interface Person {
    name: string;
    age: number;
    sayHello: () => void;
  }

  let user: Person = {
    name: 'Alice',
    age: 30,
    sayHello: () => console.log('Hello!'),
  };
  ```

  3. **Классы (Classes):**

  - Классы предоставляют возможность создавать объекты и применять принципы объектно-ориентированного программирования (ООП) в TypeScript.

  Пример:

  ```typescript
  class Animal {
    constructor(public name: string) {}

    makeSound(): void {
      console.log('Some generic sound');
    }
  }

  class Dog extends Animal {
    makeSound(): void {
      console.log('Woof! Woof!');
    }
  }

  const myDog = new Dog('Buddy');
  myDog.makeSound(); // Output: Woof! Woof!
  ```

  4. **Перечисления (Enums):**

  - Перечисления представляют собой набор именованных значений, что делает код более читаемым и поддерживаемым.

  Пример:

  ```typescript
  enum Color {
    Red,
    Green,
    Blue,
  }

  let myColor: Color = Color.Green;
  ```

  5. **Генерики (Generics):**

  - Генерики предоставляют возможность создавать компоненты, которые могут работать с различными типами данных, обеспечивая безопасность типов.

  Пример:

  ```typescript
  function identity<T>(arg: T): T {
    return arg;
  }

  let result: number = identity(123);
  ```

  Эти компоненты обеспечивают основные возможности TypeScript, позволяя разработчикам более эффективно управлять типами данных и повышать надежность кода.]()

- [Плюсы использования TypeScript?](https://youtu.be/TOn-1RrowKE?t=529)
- [Минусы использования TypeScript?](https://youtu.be/TOn-1RrowKE?t=613)
- [Типы в TypeScript?](https://youtu.be/TOn-1RrowKE?t=391)
- Вопрос [Что такое декораторы в TypeScript?]()

  - Ответ [В TypeScript декораторы - это особый вид синтаксического сахара, который позволяет изменять поведение классов, методов, свойств или параметров функций. Декораторы добавляются с использованием символа `@` перед определением класса, метода или свойства.

  Декораторы предоставляют способ метапрограммирования, позволяя изменять структуру или поведение кода на этапе его объявления. Они часто используются в фреймворках, таких как Angular, где они могут использоваться для добавления метаданных, обработки аспектов или создания middleware.

  Пример декоратора для класса:

  ```typescript
  function MyDecorator(target: Function) {
    // Логика, выполняемая при применении декоратора к классу
    console.log('Class decorator applied');
  }

  @MyDecorator
  class MyClass {
    // ...
  }
  ```

  В этом примере `MyDecorator` - это декоратор для класса. Когда этот декоратор применяется к классу `MyClass`, функция `MyDecorator` выполняется.

  Пример декоратора для метода:

  ```typescript
  function LogMethod(target: any, key: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
      console.log(`Method ${key} called with arguments: ${JSON.stringify(args)}`);
      const result = originalMethod.apply(this, args);
      console.log(`Method ${key} returned: ${JSON.stringify(result)}`);
      return result;
    };

    return descriptor;
  }

  class ExampleClass {
    @LogMethod
    add(a: number, b: number): number {
      return a + b;
    }
  }

  const exampleInstance = new ExampleClass();
  exampleInstance.add(2, 3); // Метод add будет залогирован
  ```

  В этом примере `LogMethod` - это декоратор для метода. Он логирует входные параметры и возвращаемое значение метода `add`.

  Декораторы предоставляют мощный механизм расширения функциональности и изменения поведения в TypeScript, но их использование требует внимания, так как они могут усложнить код и его понимание, особенно в более сложных сценариях.]()

- [Поддерживает ли TypeScript перегрузку функций?]()
  Да, TypeScript поддерживает перегрузку функций, но с определёнными ограничениями. Перегрузка функций в TypeScript реализуется с помощью перегрузки сигнатур функций (overload signatures), что позволяет объявить несколько версий одной и той же функции с разными типами аргументов или возвращаемыми значениями.

  ### Как работает перегрузка функций в TypeScript

  Перегрузка функций в TypeScript состоит из двух частей:

  1. **Сигнатуры перегрузки (overload signatures):** Эти сигнатуры определяют возможные типы аргументов и возвращаемых значений.
  2. **Фактическая реализация функции:** Реализация функции должна соответствовать всем перегрузкам и использовать механизм проверки типов, чтобы правильно обрабатывать различные сигнатуры.

  ### Пример перегрузки функций

  ```typescript
  // Определение сигнатур перегрузки
  function getLength(input: string): number;
  function getLength(input: any[]): number;

  // Реализация функции, соответствующая всем перегрузкам
  function getLength(input: string | any[]): number {
    return input.length;
  }

  // Примеры использования функции
  const lengthOfString = getLength('Hello'); // Результат: 5
  const lengthOfArray = getLength([1, 2, 3]); // Результат: 3
  ```

  ### Объяснение:

  1. **Сигнатуры перегрузки:**

  - `function getLength(input: string): number;` — первая сигнатура перегрузки, которая принимает строку и возвращает число.
  - `function getLength(input: any[]): number;` — вторая сигнатура перегрузки, которая принимает массив и возвращает число.

  2. **Реализация функции:**

  - Реализация функции `getLength` принимает объединённый тип (`string | any[]`), чтобы обработать оба варианта входных данных.
  - Внутри функции определяется общая логика, которая будет работать для всех перегрузок.

  ### Ограничения перегрузки функций в TypeScript

  - Реализация функции должна охватывать все возможные варианты, заданные в сигнатурах перегрузки.
  - TypeScript не поддерживает фактическую перегрузку на уровне исполнения, как это делают языки, такие как C++ или Java. Перегрузка в TypeScript — это, по сути, средство проверки типов, которое обеспечивается на этапе компиляции, но на этапе выполнения функция одна и та же.

  ### Заключение

  Перегрузка функций в TypeScript предоставляет гибкость при работе с различными типами аргументов и позволяет создавать функции с несколькими сигнатурами, обеспечивая лучшую проверку типов и документацию кода.

- [Разница между типом (`type`) и интерфейсом (`interface`)?]()
  В TypeScript есть два способа определения типов объектов: с помощью `type` и `interface`. Оба инструмента позволяют описывать структуры данных, но они имеют различия в возможностях, синтаксисе и использовании. Давайте рассмотрим основные различия между `type` и `interface`.

  ### 1. **Основное использование**

  - **`type`:** Используется для создания псевдонимов типов (type aliases), которые могут представлять любой тип данных: примитивы, объединения, кортежи, объекты, функции и так далее.

    ```typescript
    type Point = {
      x: number;
      y: number;
    };

    type ID = string | number; // Объединение типов
    ```

  - **`interface`:** Используется для описания структур объектов, классов или функций. Интерфейсы обычно применяются для определения контрактов (структур данных) в объектно-ориентированном программировании.
    ```typescript
    interface Point {
      x: number;
      y: number;
    }
    ```

  ### 2. **Расширение и объединение**

  - **`interface`:** Поддерживает наследование с помощью ключевого слова `extends`, а также объединение (declaration merging), позволяя одному и тому же имени интерфейса расширяться в разных местах.

    ```typescript
    interface Point {
      x: number;
    }

    interface Point {
      y: number;
    }

    // После объединения: { x: number, y: number }
    const point: Point = { x: 1, y: 2 };
    ```

  - **`type`:** Поддерживает объединение (intersection) с использованием оператора `&`, но не поддерживает декларативное объединение.

    ```typescript
    type Point = { x: number } & { y: number }; // Объединение типов

    type NamedPoint = Point & { name: string }; // Наследование через объединение
    ```

  ### 3. **Синтаксическая гибкость**

  - **`type`:** Более гибкий, чем `interface`, позволяет создавать псевдонимы для любого типа данных, включая примитивы, объединения, кортежи, функции и объекты.

    ```typescript
    type StringOrNumber = string | number;
    type Tuple = [number, string];
    type Callback = (x: number) => void;
    ```

  - **`interface`:** Ограничен описанием объектов, классов и функций, но не поддерживает создание объединений или псевдонимов для примитивных типов.
    ```typescript
    interface Callback {
      (x: number): void;
    }
    ```

  ### 4. **Рассмотрение конфликтов типов**

  - **`interface`:** TypeScript автоматически объединяет интерфейсы с одинаковыми именами, что может быть полезно для добавления новых свойств в существующий интерфейс.

    ```typescript
    interface User {
      name: string;
    }

    interface User {
      age: number;
    }

    // User: { name: string; age: number }
    ```

  - **`type`:** Если создать два `type` с одинаковыми именами, это вызовет ошибку, так как объединение псевдонимов типов не поддерживается.
    ```typescript
    type User = { name: string };
    // type User = { age: number }; // Ошибка: Duplicate identifier 'User'.
    ```

  ### 5. **Использование с классами**

  - **`interface`:** Часто используется для описания контракта класса. Классы могут реализовывать (`implements`) интерфейсы, что обеспечивает проверку структуры на этапе компиляции.

    ```typescript
    interface Printable {
      print(): void;
    }

    class Document implements Printable {
      print() {
        console.log('Printing document...');
      }
    }
    ```

  - **`type`:** Не может быть использован с ключевым словом `implements` в классе, но может использоваться для определения типов свойств или параметров.

  ### 6. **Компиляторная оптимизация и ошибки**

  - **`interface`:** Более эффективен для компилятора TypeScript и предпочтителен в случаях, когда вы описываете структуры объектов или классов.
  - **`type`:** Гибче, но менее оптимален для некоторых компиляторных задач.

  ### Заключение

  - Используйте **`interface`** для описания объектов, классов и контрактов между частями кода.
  - Используйте **`type`** для создания псевдонимов сложных типов, таких как объединения, кортежи, или любые другие типы, которые не могут быть описаны с помощью интерфейсов.

  Оба подхода имеют свои преимущества и могут использоваться в зависимости от требований проекта и предпочтений команды.

- [Что такое JSX в TypeScript? Какие режимы JSX поддерживает TypeScript?]()

  ### Что такое JSX в TypeScript?

  **JSX** (JavaScript XML) — это синтаксическое расширение для JavaScript, которое позволяет писать разметку в стиле HTML прямо внутри кода JavaScript. JSX часто используется в React для описания структуры пользовательского интерфейса. TypeScript поддерживает JSX, чтобы обеспечить статическую типизацию и улучшить разработку приложений на React.

  В контексте TypeScript, **JSX** позволяет разработчикам:

  - Писать компоненты React с типизированными пропсами.
  - Использовать расширенные возможности TypeScript, такие как интерфейсы и типы, для обеспечения лучшей проверки типов и автодополнения в редакторе.
  - Улучшить читаемость и поддержку кода благодаря статической типизации.

  ### Пример использования JSX в TypeScript

  Вот пример компонента React, написанного с использованием TypeScript и JSX:

  ```tsx
  import React from 'react';

  // Определение типов для пропсов
  interface GreetingProps {
    name: string;
  }

  // Компонент с использованием JSX
  const Greeting: React.FC<GreetingProps> = ({ name }) => {
    return <h1>Hello, {name}!</h1>;
  };

  export default Greeting;
  ```

  ### Режимы JSX, поддерживаемые TypeScript

  TypeScript поддерживает несколько режимов трансформации JSX, которые определяются с помощью параметра `jsx` в файле `tsconfig.json`. Эти режимы управляют тем, как компилятор TypeScript будет обрабатывать JSX-код и во что его преобразует.

  #### Поддерживаемые режимы JSX

  1. **`"preserve"`**

  - **Описание:** Этот режим сохраняет код JSX в скомпилированном выходном файле. Это полезно, когда последующая обработка кода будет выполняться другими инструментами, такими как Babel или Webpack.
  - **Использование:** Подходит для проектов, где требуется дальнейшая трансформация или минификация JSX.
  - **Пример настройки:**
    ```json
    {
      "compilerOptions": {
        "jsx": "preserve"
      }
    }
    ```

  2. **`"react"` (или `"react-jsx"`)**

  - **Описание:** Преобразует JSX в вызовы `React.createElement`. Этот режим подходит для стандартных проектов на React.
  - **Использование:** Используется в большинстве проектов на React, чтобы непосредственно преобразовывать JSX в код, который понимает React.
  - **Пример настройки:**
    ```json
    {
      "compilerOptions": {
        "jsx": "react"
      }
    }
    ```

  3. **`"react-jsx"` (новый режим с TypeScript 4.1)**

  - **Описание:** Этот режим выполняет оптимизированную трансформацию JSX, поддерживающую новые функции, такие как автоматический импорт React и улучшенную типизацию. Он генерирует более эффективный и компактный код.
  - **Использование:** Рекомендуется для новых проектов на React, чтобы использовать улучшенные возможности TypeScript.
  - **Пример настройки:**
    ```json
    {
      "compilerOptions": {
        "jsx": "react-jsx"
      }
    }
    ```

  4. **`"react-jsxdev"`**

  - **Описание:** Специальный режим для разработки, который генерирует дополнительную информацию для отладки и диагностики. Этот режим предоставляет более подробные сообщения об ошибках и улучшает разработку в режиме отладки.
  - **Использование:** Рекомендуется использовать во время разработки для улучшения диагностики и отладки.
  - **Пример настройки:**
    ```json
    {
      "compilerOptions": {
        "jsx": "react-jsxdev"
      }
    }
    ```

  ### Как выбрать режим JSX?

  Выбор режима JSX зависит от вашего проекта:

  - Используйте **`"preserve"`**, если вы используете внешние инструменты (например, Babel) для трансформации JSX.
  - Используйте **`"react"`** для стандартных React-приложений.
  - Используйте **`"react-jsx"`** для новых проектов на React, чтобы воспользоваться преимуществами улучшенной трансформации TypeScript.
  - Используйте **`"react-jsxdev"`** во время разработки для улучшенной диагностики.

  ### Заключение

  JSX в TypeScript позволяет типизировать и проверять компоненты React с помощью TypeScript. Выбор правильного режима JSX зависит от потребностей вашего проекта и инструментов, которые вы используете для сборки и трансформации кода.

- [Что такое директивы с тремя наклонными чертами (Triple-Slash Directives), их типы?]()
  **Директивы с тремя наклонными чертами (Triple-Slash Directives)** — это специальные комментарии в TypeScript, которые используются для предоставления инструкций компилятору. Они могут управлять порядком подключения файлов, подключать определения типов, а также влиять на импорт модулей. Эти директивы начинаются с `///` и должны быть первыми в файле (до любого другого кода или импортов).

  ### Типы директив с тремя наклонными чертами

  1. **`/// <reference path="..." />`**

  - **Описание:** Используется для подключения другого файла TypeScript по пути, указанному в атрибуте `path`.
  - **Применение:** Позволяет явно указывать зависимости между файлами TypeScript, особенно полезно для старых проектов, которые не используют модули.
  - **Пример:**
    ```typescript
    /// <reference path="./moduleA.ts" />
    ```
  - **Пояснение:** Эта директива указывает компилятору, что необходимо обработать файл `moduleA.ts` перед текущим файлом.

  2. **`/// <reference types="..." />`**

  - **Описание:** Указывает, что текущий файл зависит от набора определений типов. Директива используется для загрузки типов, объявленных в глобальном пространстве имен (например, в файлах `.d.ts`).
  - **Применение:** Полезно при использовании глобальных библиотек или модулей, для которых требуется доступ к их типам.
  - **Пример:**
    ```typescript
    /// <reference types="node" />
    ```
  - **Пояснение:** Эта директива указывает компилятору использовать типы из пакета `@types/node` (определения типов для Node.js).

  3. **`/// <reference lib="..." />`**

  - **Описание:** Используется для включения встроенных библиотек TypeScript (например, библиотек для работы с DOM, ECMAScript и т.д.).
  - **Применение:** Позволяет явно указывать библиотеки, которые необходимо включить в компиляцию.
  - **Пример:**
    ```typescript
    /// <reference lib="dom" />
    /// <reference lib="es2020" />
    ```
  - **Пояснение:** Эти директивы добавляют встроенные библиотеки `dom` и `es2020`, которые содержат типы и функции, определенные в DOM и стандарте ECMAScript 2020.

  4. **`/// <amd-module name="..." />`**

  - **Описание:** Эта директива используется для указания имени модуля при использовании компиляции в формате AMD (Asynchronous Module Definition).
  - **Применение:** Полезно в сценариях, где необходимо явно определить имя модуля при использовании `amd` в конфигурации TypeScript.
  - **Пример:**
    ```typescript
    /// <amd-module name="myModule" />
    ```
  - **Пояснение:** Эта директива указывает компилятору TypeScript, что имя модуля должно быть `myModule`.

  ### Особенности использования директив с тремя наклонными чертами

  - **Расположение в файле:** Директивы должны быть в начале файла, перед любым другим кодом или импортами.
  - **Порядок компиляции:** Компилятор TypeScript использует эти директивы для определения порядка компиляции файлов.
  - **Устаревший механизм:** С появлением современных модульных систем (CommonJS, ES Modules) и менеджеров пакетов (npm), использование директив `/// <reference path="..." />` постепенно уменьшается. Однако они все еще полезны для настройки среды разработки или в специфических случаях (например, для глобальных типов).

  ### Заключение

  Директивы с тремя наклонными чертами в TypeScript предоставляют компилятору инструкции о зависимостях файлов и типах. Они остаются полезными в определенных сценариях, особенно когда нужно явно управлять компиляцией или загружать глобальные определения типов.

- [Что такое внешние объявления переменных (ambient declaration) в TypeScript?]()
  **Внешние объявления переменных (Ambient Declarations)** в TypeScript — это способ объявить типы и переменные, которые уже существуют в глобальной области видимости, но не были определены в коде TypeScript. Внешние объявления используются для интеграции с существующим JavaScript-кодом или сторонними библиотеками, чтобы TypeScript мог проверить типы и предоставить автодополнение и поддержку типов в редакторе.

  ### Основные концепции внешних объявлений

  1. **`declare`**: Ключевое слово `declare` используется для того, чтобы сообщить TypeScript, что переменная, функция, класс, модуль или пространство имен уже существуют где-то в глобальной области видимости. TypeScript не будет генерировать никакого кода для этих объявлений; они существуют только на этапе проверки типов.

  2. **Файлы деклараций (`*.d.ts`)**: Внешние объявления обычно хранятся в файлах с расширением `.d.ts`. Эти файлы содержат только объявления типов, интерфейсов и модулей, но не содержат реализаций. Они часто используются для предоставления типов для сторонних библиотек.

  ### Примеры использования внешних объявлений

  #### Пример 1: Объявление глобальной переменной

  Если в вашем проекте используется переменная, объявленная в JavaScript-коде, вы можете использовать `declare` для её объявления в TypeScript:

  ```typescript
  // example.d.ts
  declare var API_KEY: string;
  ```

  Это объявление сообщает TypeScript, что переменная `API_KEY` существует в глобальной области видимости и имеет тип `string`.

  #### Пример 2: Объявление глобальной функции

  Если в вашем проекте используется функция, объявленная в JavaScript, вы можете использовать `declare` для объявления её типа:

  ```typescript
  // example.d.ts
  declare function initializeApp(config: object): void;
  ```

  Это объявление сообщает TypeScript, что функция `initializeApp` существует в глобальной области видимости и принимает один параметр типа `object` и не возвращает значения (`void`).

  #### Пример 3: Объявление внешних модулей

  Для работы с сторонними библиотеками, не написанными на TypeScript, можно объявить модуль:

  ```typescript
  // example.d.ts
  declare module "my-library" {
    export function doSomething(): void;
  }
  ```

  Это объявление сообщает TypeScript, что существует модуль `"my-library"`, который экспортирует функцию `doSomething`.

  ### Применение внешних объявлений

  - **Сторонние библиотеки:** TypeScript часто используется для написания определений типов для сторонних библиотек, таких как jQuery, lodash, React и других, которые не написаны на TypeScript. Эти определения типов предоставляются в виде файлов `.d.ts`, которые можно найти в репозитории DefinitelyTyped или в пакетах `@types` на npm.
    
  - **Глобальные переменные и функции:** Когда проект использует глобальные переменные или функции, которые не определены в коде TypeScript, `declare` помогает TypeScript «понять» их существование и типы.

  - **Интеграция с JavaScript:** Если у вас есть существующий проект на JavaScript и вы хотите добавить поддержку TypeScript, вы можете использовать внешние объявления для описания уже существующего кода, чтобы TypeScript мог использовать его без изменений.

  ### Пример использования в файле деклараций

  Предположим, вы используете библиотеку `jquery` в своем проекте. Вам нужно предоставить информацию о типах для этой библиотеки:

  ```typescript
  // jquery.d.ts
  declare var $: {
    (selector: string): any;
    ajax(settings: any): void;
    // и другие объявления...
  };
  ```

  Это объявление позволяет TypeScript распознать символ `$` как глобальную переменную, предоставленную jQuery, и использовать её в вашем коде.

  ### Файлы деклараций для модулей

  Если вы хотите объявить типы для модуля:

  ```typescript
  // lodash.d.ts
  declare module "lodash" {
    export function chunk<T>(array: T[], size?: number): T[][];
    // другие объявления...
  }
  ```

  Это позволяет TypeScript распознавать импортируемые функции из модуля `lodash` и проверять их типы в вашем проекте.

  ### Заключение

  **Внешние объявления переменных** — это мощный инструмент в TypeScript для интеграции существующего JavaScript-кода и сторонних библиотек. Они позволяют TypeScript проверять типы и использовать автодополнение даже для кода, который не был написан на TypeScript, что улучшает качество кода и разработку в целом.
- [Разница между абстрактным классом (abstract class) и интерфейсом (interface)?](https://youtu.be/TOn-1RrowKE?t=436)
- [Какие элементы ООП поддерживаются в TypeScript?](https://youtu.be/TOn-1RrowKE?t=688)
- [Модификаторы доступа в TypeScript?](https://youtu.be/TOn-1RrowKE?t=749)
- [Разница между внутренним (Internal Module) и внешним модулями (External Module)?](https://youtu.be/TOn-1RrowKE?t=807)
- [Что такое декораторы в TypeScript?](https://youtu.be/VYQl2GhbCUs?t=29)
- [Как TypeScript поддерживает необязательные и дефолтные параметры в функции?](https://youtu.be/VYQl2GhbCUs?t=102)
- [Что такое перечисление (`enum`)?](https://youtu.be/VYQl2GhbCUs?t=168)
- [Для чего в TypeScript используется `NoImplicitAny`?](https://youtu.be/54C3u9aCtoU?t=123)
- [Разница между типами “Объединение” (`|`) и “Пересечение” (`&`)?](https://youtu.be/54C3u9aCtoU?t=193)
- [Что такое общие типы (`generic`) в TypeScript?](https://youtu.be/OMQzqLyINnI?t=29)
- [Какие области видимости доступны в TypeScript?](https://youtu.be/OMQzqLyINnI?t=101)
- [Что такое `.map` файл, как и зачем его использовать?](https://youtu.be/OMQzqLyINnI?t=146)
- [Можно ли использовать TypeScript в серверной разработке?](https://youtu.be/OMQzqLyINnI?t=199)
- [Для чего в TypeScript используют ключевое слово `declare`?](https://youtu.be/OMQzqLyINnI?t=281)
- [Разница между типами `void`, `never` и `unknown`?]()
- Вопрос [Разница между типами `void`, `never` и `unknown`?]()

  - Ответ [Конечно, давайте разберем каждый тип:

  1. **`void`**: Этот тип представляет отсутствие значения. Он обычно используется для обозначения, что функция ничего не возвращает. Например:

  ```typescript
  function logMessage(message: string): void {
    console.log(message);
  }
  ```

  В этом примере `void` указывает, что функция `logMessage` не возвращает никакого значения.

  2. **`never`**: Этот тип представляет собой тип, значение которого никогда не произойдет. Он обычно используется для функций, которые никогда не завершаются или для обработки ошибок. Например:

  ```typescript
  function throwError(message: string): never {
    throw new Error(message);
  }
  ```

  В этом примере `never` указывает, что функция `throwError` никогда не завершится нормальным образом, потому что она всегда бросает ошибку.

  3. **`unknown`**: Этот тип представляет собой тип, о котором ничего неизвестно. Он используется в ситуациях, когда тип значения может быть известен только во время выполнения программы или когда тип значения может зависеть от внешних факторов. Например:

  ```typescript
  let userInput: unknown;
  let userName: string;

  userInput = 5;
  userInput = 'Max';

  // Нельзя присвоить переменной тип unknown напрямую переменной типа string
  // userName = userInput; // Ошибка

  // Но можно выполнить проверку типа
  if (typeof userInput === 'string') {
    userName = userInput;
  }
  ```

  В этом примере `unknown` используется для переменной `userInput`, потому что ее тип может быть неизвестен до выполнения программы, и затем выполняется проверка типа перед присваиванием значения переменной `userName`.

  Итак, основные различия:

  - `void`: Отсутствие значения, обычно используется для функций, которые ничего не возвращают.
  - `never`: Тип, значение которого никогда не произойдет, часто используется для обработки ошибок или функций, которые никогда не завершаются.
  - `unknown`: Тип, о котором ничего неизвестно, обычно используется в ситуациях, когда тип значения может быть известен только во время выполнения программы.]()

- Вопрос [Что такое декораторы в TypeScript?]()

  - Ответ []()

- Вопрос [Что такое декораторы в TypeScript?]()

  - Ответ []()

- Вопрос [Что такое декораторы в TypeScript?]()

  - Ответ []()

- [Как вы отлавливаете ошибки в TypeScript коде?](https://youtu.be/DQ0BLu6rZYc?t=802)
